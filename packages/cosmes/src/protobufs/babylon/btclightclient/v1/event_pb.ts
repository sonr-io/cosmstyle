// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file babylon/btclightclient/v1/event.proto (package babylon.btclightclient.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { BTCHeaderInfo } from "./btclightclient_pb.js";

/**
 * The header included in the event is the block in the history
 * of the current mainchain to which we are rolling back to.
 * In other words, there is one rollback event emitted per re-org, to the
 * greatest common ancestor of the old and the new fork.
 *
 * @generated from message babylon.btclightclient.v1.EventBTCRollBack
 */
export class EventBTCRollBack extends Message<EventBTCRollBack> {
  /**
   * @generated from field: babylon.btclightclient.v1.BTCHeaderInfo header = 1;
   */
  header?: BTCHeaderInfo;

  constructor(data?: PartialMessage<EventBTCRollBack>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btclightclient.v1.EventBTCRollBack";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: BTCHeaderInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventBTCRollBack {
    return new EventBTCRollBack().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventBTCRollBack {
    return new EventBTCRollBack().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventBTCRollBack {
    return new EventBTCRollBack().fromJsonString(jsonString, options);
  }

  static equals(a: EventBTCRollBack | PlainMessage<EventBTCRollBack> | undefined, b: EventBTCRollBack | PlainMessage<EventBTCRollBack> | undefined): boolean {
    return proto3.util.equals(EventBTCRollBack, a, b);
  }
}

/**
 * EventBTCRollForward is emitted on Msg/InsertHeader
 * The header included in the event is the one the main chain is extended with.
 * In the event of a reorg, each block on the new fork that comes after
 * the greatest common ancestor will have a corresponding roll forward event.
 *
 * @generated from message babylon.btclightclient.v1.EventBTCRollForward
 */
export class EventBTCRollForward extends Message<EventBTCRollForward> {
  /**
   * @generated from field: babylon.btclightclient.v1.BTCHeaderInfo header = 1;
   */
  header?: BTCHeaderInfo;

  constructor(data?: PartialMessage<EventBTCRollForward>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btclightclient.v1.EventBTCRollForward";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: BTCHeaderInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventBTCRollForward {
    return new EventBTCRollForward().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventBTCRollForward {
    return new EventBTCRollForward().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventBTCRollForward {
    return new EventBTCRollForward().fromJsonString(jsonString, options);
  }

  static equals(a: EventBTCRollForward | PlainMessage<EventBTCRollForward> | undefined, b: EventBTCRollForward | PlainMessage<EventBTCRollForward> | undefined): boolean {
    return proto3.util.equals(EventBTCRollForward, a, b);
  }
}

/**
 * EventBTCHeaderInserted is emitted on Msg/InsertHeader
 * The header included in the event is the one that was added to the
 * on chain BTC storage.
 *
 * @generated from message babylon.btclightclient.v1.EventBTCHeaderInserted
 */
export class EventBTCHeaderInserted extends Message<EventBTCHeaderInserted> {
  /**
   * @generated from field: babylon.btclightclient.v1.BTCHeaderInfo header = 1;
   */
  header?: BTCHeaderInfo;

  constructor(data?: PartialMessage<EventBTCHeaderInserted>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btclightclient.v1.EventBTCHeaderInserted";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: BTCHeaderInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventBTCHeaderInserted {
    return new EventBTCHeaderInserted().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventBTCHeaderInserted {
    return new EventBTCHeaderInserted().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventBTCHeaderInserted {
    return new EventBTCHeaderInserted().fromJsonString(jsonString, options);
  }

  static equals(a: EventBTCHeaderInserted | PlainMessage<EventBTCHeaderInserted> | undefined, b: EventBTCHeaderInserted | PlainMessage<EventBTCHeaderInserted> | undefined): boolean {
    return proto3.util.equals(EventBTCHeaderInserted, a, b);
  }
}

