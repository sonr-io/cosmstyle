// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file babylon/checkpointing/v1/checkpoint.proto (package babylon.checkpointing.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { ExtendedCommitInfo } from "../../../tendermint/abci/types_pb.js";

/**
 * CheckpointStatus is the status of a checkpoint.
 *
 * @generated from enum babylon.checkpointing.v1.CheckpointStatus
 */
export enum CheckpointStatus {
  /**
   * ACCUMULATING defines a checkpoint that is awaiting for BLS signatures.
   *
   * @generated from enum value: CKPT_STATUS_ACCUMULATING = 0;
   */
  CKPT_STATUS_ACCUMULATING = 0,

  /**
   * SEALED defines a checkpoint that has accumulated sufficient BLS signatures.
   *
   * @generated from enum value: CKPT_STATUS_SEALED = 1;
   */
  CKPT_STATUS_SEALED = 1,

  /**
   * SUBMITTED defines a checkpoint that is included on BTC.
   *
   * @generated from enum value: CKPT_STATUS_SUBMITTED = 2;
   */
  CKPT_STATUS_SUBMITTED = 2,

  /**
   * CONFIRMED defines a checkpoint that is k-deep on BTC.
   *
   * @generated from enum value: CKPT_STATUS_CONFIRMED = 3;
   */
  CKPT_STATUS_CONFIRMED = 3,

  /**
   * FINALIZED defines a checkpoint that is w-deep on BTC.
   *
   * @generated from enum value: CKPT_STATUS_FINALIZED = 4;
   */
  CKPT_STATUS_FINALIZED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(CheckpointStatus)
proto3.util.setEnumType(CheckpointStatus, "babylon.checkpointing.v1.CheckpointStatus", [
  { no: 0, name: "CKPT_STATUS_ACCUMULATING" },
  { no: 1, name: "CKPT_STATUS_SEALED" },
  { no: 2, name: "CKPT_STATUS_SUBMITTED" },
  { no: 3, name: "CKPT_STATUS_CONFIRMED" },
  { no: 4, name: "CKPT_STATUS_FINALIZED" },
]);

/**
 * RawCheckpoint wraps the BLS multi sig with metadata
 *
 * @generated from message babylon.checkpointing.v1.RawCheckpoint
 */
export class RawCheckpoint extends Message<RawCheckpoint> {
  /**
   * epoch_num defines the epoch number the raw checkpoint is for
   *
   * @generated from field: uint64 epoch_num = 1;
   */
  epochNum = protoInt64.zero;

  /**
   * block_hash defines the 'BlockID.Hash', which is the hash of
   * the block that individual BLS sigs are signed on
   *
   * @generated from field: bytes block_hash = 2;
   */
  blockHash = new Uint8Array(0);

  /**
   * bitmap defines the bitmap that indicates the signers of the BLS multi sig
   *
   * @generated from field: bytes bitmap = 3;
   */
  bitmap = new Uint8Array(0);

  /**
   * bls_multi_sig defines the multi sig that is aggregated from individual BLS
   * sigs
   *
   * @generated from field: bytes bls_multi_sig = 4;
   */
  blsMultiSig = new Uint8Array(0);

  constructor(data?: PartialMessage<RawCheckpoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.checkpointing.v1.RawCheckpoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "epoch_num", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "block_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "bitmap", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "bls_multi_sig", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RawCheckpoint {
    return new RawCheckpoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RawCheckpoint {
    return new RawCheckpoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RawCheckpoint {
    return new RawCheckpoint().fromJsonString(jsonString, options);
  }

  static equals(a: RawCheckpoint | PlainMessage<RawCheckpoint> | undefined, b: RawCheckpoint | PlainMessage<RawCheckpoint> | undefined): boolean {
    return proto3.util.equals(RawCheckpoint, a, b);
  }
}

/**
 * RawCheckpointWithMeta wraps the raw checkpoint with metadata.
 *
 * @generated from message babylon.checkpointing.v1.RawCheckpointWithMeta
 */
export class RawCheckpointWithMeta extends Message<RawCheckpointWithMeta> {
  /**
   * @generated from field: babylon.checkpointing.v1.RawCheckpoint ckpt = 1;
   */
  ckpt?: RawCheckpoint;

  /**
   * status defines the status of the checkpoint
   *
   * @generated from field: babylon.checkpointing.v1.CheckpointStatus status = 2;
   */
  status = CheckpointStatus.CKPT_STATUS_ACCUMULATING;

  /**
   * bls_aggr_pk defines the aggregated BLS public key
   *
   * @generated from field: bytes bls_aggr_pk = 3;
   */
  blsAggrPk = new Uint8Array(0);

  /**
   * power_sum defines the accumulated voting power for the checkpoint
   *
   * @generated from field: uint64 power_sum = 4;
   */
  powerSum = protoInt64.zero;

  /**
   * lifecycle defines the lifecycle of this checkpoint, i.e., each state
   * transition and the time (in both timestamp and block height) of this
   * transition.
   *
   * @generated from field: repeated babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5;
   */
  lifecycle: CheckpointStateUpdate[] = [];

  constructor(data?: PartialMessage<RawCheckpointWithMeta>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.checkpointing.v1.RawCheckpointWithMeta";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ckpt", kind: "message", T: RawCheckpoint },
    { no: 2, name: "status", kind: "enum", T: proto3.getEnumType(CheckpointStatus) },
    { no: 3, name: "bls_aggr_pk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "power_sum", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "lifecycle", kind: "message", T: CheckpointStateUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RawCheckpointWithMeta {
    return new RawCheckpointWithMeta().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RawCheckpointWithMeta {
    return new RawCheckpointWithMeta().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RawCheckpointWithMeta {
    return new RawCheckpointWithMeta().fromJsonString(jsonString, options);
  }

  static equals(a: RawCheckpointWithMeta | PlainMessage<RawCheckpointWithMeta> | undefined, b: RawCheckpointWithMeta | PlainMessage<RawCheckpointWithMeta> | undefined): boolean {
    return proto3.util.equals(RawCheckpointWithMeta, a, b);
  }
}

/**
 * InjectedCheckpoint wraps the checkpoint and the extended votes
 *
 * @generated from message babylon.checkpointing.v1.InjectedCheckpoint
 */
export class InjectedCheckpoint extends Message<InjectedCheckpoint> {
  /**
   * @generated from field: babylon.checkpointing.v1.RawCheckpointWithMeta ckpt = 1;
   */
  ckpt?: RawCheckpointWithMeta;

  /**
   * extended_commit_info is the commit info including the vote extensions
   * from the previous proposal
   *
   * @generated from field: tendermint.abci.ExtendedCommitInfo extended_commit_info = 2;
   */
  extendedCommitInfo?: ExtendedCommitInfo;

  constructor(data?: PartialMessage<InjectedCheckpoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.checkpointing.v1.InjectedCheckpoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ckpt", kind: "message", T: RawCheckpointWithMeta },
    { no: 2, name: "extended_commit_info", kind: "message", T: ExtendedCommitInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InjectedCheckpoint {
    return new InjectedCheckpoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InjectedCheckpoint {
    return new InjectedCheckpoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InjectedCheckpoint {
    return new InjectedCheckpoint().fromJsonString(jsonString, options);
  }

  static equals(a: InjectedCheckpoint | PlainMessage<InjectedCheckpoint> | undefined, b: InjectedCheckpoint | PlainMessage<InjectedCheckpoint> | undefined): boolean {
    return proto3.util.equals(InjectedCheckpoint, a, b);
  }
}

/**
 * CheckpointStateUpdate defines a state transition on the checkpoint.
 *
 * @generated from message babylon.checkpointing.v1.CheckpointStateUpdate
 */
export class CheckpointStateUpdate extends Message<CheckpointStateUpdate> {
  /**
   * state defines the event of a state transition towards this state
   *
   * @generated from field: babylon.checkpointing.v1.CheckpointStatus state = 1;
   */
  state = CheckpointStatus.CKPT_STATUS_ACCUMULATING;

  /**
   * block_height is the height of the Babylon block that triggers the state
   * update
   *
   * @generated from field: uint64 block_height = 2;
   */
  blockHeight = protoInt64.zero;

  /**
   * block_time is the timestamp in the Babylon block that triggers the state
   * update
   *
   * @generated from field: google.protobuf.Timestamp block_time = 3;
   */
  blockTime?: Timestamp;

  constructor(data?: PartialMessage<CheckpointStateUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.checkpointing.v1.CheckpointStateUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(CheckpointStatus) },
    { no: 2, name: "block_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "block_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckpointStateUpdate {
    return new CheckpointStateUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckpointStateUpdate {
    return new CheckpointStateUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckpointStateUpdate {
    return new CheckpointStateUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: CheckpointStateUpdate | PlainMessage<CheckpointStateUpdate> | undefined, b: CheckpointStateUpdate | PlainMessage<CheckpointStateUpdate> | undefined): boolean {
    return proto3.util.equals(CheckpointStateUpdate, a, b);
  }
}

/**
 * BlsSig wraps the BLS sig with metadata.
 *
 * @generated from message babylon.checkpointing.v1.BlsSig
 */
export class BlsSig extends Message<BlsSig> {
  /**
   * epoch_num defines the epoch number that the BLS sig is signed on
   *
   * @generated from field: uint64 epoch_num = 1;
   */
  epochNum = protoInt64.zero;

  /**
   * block_hash defines the 'BlockID.Hash', which is the hash of
   * the block that individual BLS sigs are signed on
   *
   * @generated from field: bytes block_hash = 2;
   */
  blockHash = new Uint8Array(0);

  /**
   * @generated from field: bytes bls_sig = 3;
   */
  blsSig = new Uint8Array(0);

  /**
   * can't find cosmos_proto.scalar when compiling due to cosmos v0.45.4 does
   * not support scalar string signer_address = 4 [(cosmos_proto.scalar) =
   * "cosmos.AddressString"]
   * the signer_address defines the address of the
   * signer
   *
   * @generated from field: string signer_address = 4;
   */
  signerAddress = "";

  /**
   * validator_address defines the validator's consensus address
   *
   * @generated from field: string validator_address = 5;
   */
  validatorAddress = "";

  constructor(data?: PartialMessage<BlsSig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.checkpointing.v1.BlsSig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "epoch_num", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "block_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "bls_sig", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "signer_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "validator_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlsSig {
    return new BlsSig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlsSig {
    return new BlsSig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlsSig {
    return new BlsSig().fromJsonString(jsonString, options);
  }

  static equals(a: BlsSig | PlainMessage<BlsSig> | undefined, b: BlsSig | PlainMessage<BlsSig> | undefined): boolean {
    return proto3.util.equals(BlsSig, a, b);
  }
}

