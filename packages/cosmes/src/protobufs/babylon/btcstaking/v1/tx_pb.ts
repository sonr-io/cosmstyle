// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file babylon/btcstaking/v1/tx.proto (package babylon.btcstaking.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Description } from "../../../cosmos/staking/v1beta1/staking_pb.js";
import { PubKey } from "../../../cosmos/crypto/secp256k1/keys_pb.js";
import { ProofOfPossession } from "./pop_pb.js";
import { TransactionInfo } from "../../btccheckpoint/v1/btccheckpoint_pb.js";
import { Params } from "./params_pb.js";

/**
 * MsgCreateFinalityProvider is the message for creating a finality provider
 *
 * @generated from message babylon.btcstaking.v1.MsgCreateFinalityProvider
 */
export class MsgCreateFinalityProvider extends Message<MsgCreateFinalityProvider> {
  /**
   * @generated from field: string signer = 1;
   */
  signer = "";

  /**
   * description defines the description terms for the finality provider
   *
   * @generated from field: cosmos.staking.v1beta1.Description description = 2;
   */
  description?: Description;

  /**
   * commission defines the commission rate of the finality provider
   *
   * @generated from field: string commission = 3;
   */
  commission = "";

  /**
   * babylon_pk is the Babylon secp256k1 PK of this finality provider
   *
   * @generated from field: cosmos.crypto.secp256k1.PubKey babylon_pk = 4;
   */
  babylonPk?: PubKey;

  /**
   * btc_pk is the Bitcoin secp256k1 PK of this finality provider
   * the PK follows encoding in BIP-340 spec
   *
   * @generated from field: bytes btc_pk = 5;
   */
  btcPk = new Uint8Array(0);

  /**
   * pop is the proof of possession of babylon_pk and btc_pk
   *
   * @generated from field: babylon.btcstaking.v1.ProofOfPossession pop = 6;
   */
  pop?: ProofOfPossession;

  constructor(data?: PartialMessage<MsgCreateFinalityProvider>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.MsgCreateFinalityProvider";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "message", T: Description },
    { no: 3, name: "commission", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "babylon_pk", kind: "message", T: PubKey },
    { no: 5, name: "btc_pk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "pop", kind: "message", T: ProofOfPossession },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateFinalityProvider {
    return new MsgCreateFinalityProvider().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateFinalityProvider {
    return new MsgCreateFinalityProvider().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateFinalityProvider {
    return new MsgCreateFinalityProvider().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateFinalityProvider | PlainMessage<MsgCreateFinalityProvider> | undefined, b: MsgCreateFinalityProvider | PlainMessage<MsgCreateFinalityProvider> | undefined): boolean {
    return proto3.util.equals(MsgCreateFinalityProvider, a, b);
  }
}

/**
 * MsgCreateFinalityProviderResponse is the response for MsgCreateFinalityProvider
 *
 * @generated from message babylon.btcstaking.v1.MsgCreateFinalityProviderResponse
 */
export class MsgCreateFinalityProviderResponse extends Message<MsgCreateFinalityProviderResponse> {
  constructor(data?: PartialMessage<MsgCreateFinalityProviderResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.MsgCreateFinalityProviderResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateFinalityProviderResponse {
    return new MsgCreateFinalityProviderResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateFinalityProviderResponse {
    return new MsgCreateFinalityProviderResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateFinalityProviderResponse {
    return new MsgCreateFinalityProviderResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateFinalityProviderResponse | PlainMessage<MsgCreateFinalityProviderResponse> | undefined, b: MsgCreateFinalityProviderResponse | PlainMessage<MsgCreateFinalityProviderResponse> | undefined): boolean {
    return proto3.util.equals(MsgCreateFinalityProviderResponse, a, b);
  }
}

/**
 * MsgEditFinalityProvider is the message for editing an existing finality provider
 *
 * @generated from message babylon.btcstaking.v1.MsgEditFinalityProvider
 */
export class MsgEditFinalityProvider extends Message<MsgEditFinalityProvider> {
  /**
   * NOTE: this signer needs to correspond to babylon_pk of the finality provider
   *
   * @generated from field: string signer = 1;
   */
  signer = "";

  /**
   * btc_pk is the Bitcoin secp256k1 PK of the finality provider to be edited
   *
   * @generated from field: bytes btc_pk = 2;
   */
  btcPk = new Uint8Array(0);

  /**
   * description defines the updated description terms for the finality provider
   *
   * @generated from field: cosmos.staking.v1beta1.Description description = 3;
   */
  description?: Description;

  /**
   * commission defines the updated commission rate of the finality provider
   *
   * @generated from field: string commission = 4;
   */
  commission = "";

  constructor(data?: PartialMessage<MsgEditFinalityProvider>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.MsgEditFinalityProvider";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "btc_pk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "description", kind: "message", T: Description },
    { no: 4, name: "commission", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgEditFinalityProvider {
    return new MsgEditFinalityProvider().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgEditFinalityProvider {
    return new MsgEditFinalityProvider().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgEditFinalityProvider {
    return new MsgEditFinalityProvider().fromJsonString(jsonString, options);
  }

  static equals(a: MsgEditFinalityProvider | PlainMessage<MsgEditFinalityProvider> | undefined, b: MsgEditFinalityProvider | PlainMessage<MsgEditFinalityProvider> | undefined): boolean {
    return proto3.util.equals(MsgEditFinalityProvider, a, b);
  }
}

/**
 * MsgEditFinalityProviderResponse is the response for MsgEditFinalityProvider
 *
 * @generated from message babylon.btcstaking.v1.MsgEditFinalityProviderResponse
 */
export class MsgEditFinalityProviderResponse extends Message<MsgEditFinalityProviderResponse> {
  constructor(data?: PartialMessage<MsgEditFinalityProviderResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.MsgEditFinalityProviderResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgEditFinalityProviderResponse {
    return new MsgEditFinalityProviderResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgEditFinalityProviderResponse {
    return new MsgEditFinalityProviderResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgEditFinalityProviderResponse {
    return new MsgEditFinalityProviderResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgEditFinalityProviderResponse | PlainMessage<MsgEditFinalityProviderResponse> | undefined, b: MsgEditFinalityProviderResponse | PlainMessage<MsgEditFinalityProviderResponse> | undefined): boolean {
    return proto3.util.equals(MsgEditFinalityProviderResponse, a, b);
  }
}

/**
 * MsgCreateBTCDelegation is the message for creating a BTC delegation
 *
 * @generated from message babylon.btcstaking.v1.MsgCreateBTCDelegation
 */
export class MsgCreateBTCDelegation extends Message<MsgCreateBTCDelegation> {
  /**
   * @generated from field: string signer = 1;
   */
  signer = "";

  /**
   * babylon_pk is the Babylon secp256k1 PK of this BTC delegation
   *
   * @generated from field: cosmos.crypto.secp256k1.PubKey babylon_pk = 2;
   */
  babylonPk?: PubKey;

  /**
   * pop is the proof of possession of babylon_pk and btc_pk
   *
   * @generated from field: babylon.btcstaking.v1.ProofOfPossession pop = 3;
   */
  pop?: ProofOfPossession;

  /**
   * btc_pk is the Bitcoin secp256k1 PK of the BTC delegator
   *
   * @generated from field: bytes btc_pk = 4;
   */
  btcPk = new Uint8Array(0);

  /**
   * fp_btc_pk_list is the list of Bitcoin secp256k1 PKs of the finality providers, if there is more than one
   * finality provider pk it means that delegation is re-staked
   *
   * @generated from field: repeated bytes fp_btc_pk_list = 5;
   */
  fpBtcPkList: Uint8Array[] = [];

  /**
   * staking_time is the time lock used in staking transaction
   *
   * @generated from field: uint32 staking_time = 6;
   */
  stakingTime = 0;

  /**
   * staking_value  is the amount of satoshis locked in staking output
   *
   * @generated from field: int64 staking_value = 7;
   */
  stakingValue = protoInt64.zero;

  /**
   * staking_tx is the staking tx along with the merkle proof of inclusion in btc block
   *
   * @generated from field: babylon.btccheckpoint.v1.TransactionInfo staking_tx = 8;
   */
  stakingTx?: TransactionInfo;

  /**
   * slashing_tx is the slashing tx
   * Note that the tx itself does not contain signatures, which are off-chain.
   *
   * @generated from field: bytes slashing_tx = 9;
   */
  slashingTx = new Uint8Array(0);

  /**
   * delegator_slashing_sig is the signature on the slashing tx by the delegator (i.e., SK corresponding to btc_pk).
   * It will be a part of the witness for the staking tx output.
   * The staking tx output further needs signatures from covenant and finality provider in
   * order to be spendable.
   *
   * @generated from field: bytes delegator_slashing_sig = 10;
   */
  delegatorSlashingSig = new Uint8Array(0);

  /**
   * unbonding_time is the time lock used when funds are being unbonded. It is be used in:
   * - unbonding transaction, time lock spending path
   * - staking slashing transaction, change output
   * - unbonding slashing transaction, change output
   * It must be smaller than math.MaxUInt16 and larger that max(MinUnbondingTime, CheckpointFinalizationTimeout)
   *
   * @generated from field: uint32 unbonding_time = 11;
   */
  unbondingTime = 0;

  /**
   * fields related to unbonding transaction
   * unbonding_tx is a bitcoin unbonding transaction i.e transaction that spends
   * staking output and sends it to the unbonding output
   *
   * @generated from field: bytes unbonding_tx = 12;
   */
  unbondingTx = new Uint8Array(0);

  /**
   * unbonding_value is amount of satoshis locked in unbonding output.
   * NOTE: staking_value and unbonding_value could be different because of the difference between the fee for staking tx and that for unbonding
   *
   * @generated from field: int64 unbonding_value = 13;
   */
  unbondingValue = protoInt64.zero;

  /**
   * unbonding_slashing_tx is the slashing tx which slash unbonding contract
   * Note that the tx itself does not contain signatures, which are off-chain.
   *
   * @generated from field: bytes unbonding_slashing_tx = 14;
   */
  unbondingSlashingTx = new Uint8Array(0);

  /**
   * delegator_unbonding_slashing_sig is the signature on the slashing tx by the delegator (i.e., SK corresponding to btc_pk).
   *
   * @generated from field: bytes delegator_unbonding_slashing_sig = 15;
   */
  delegatorUnbondingSlashingSig = new Uint8Array(0);

  constructor(data?: PartialMessage<MsgCreateBTCDelegation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.MsgCreateBTCDelegation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "babylon_pk", kind: "message", T: PubKey },
    { no: 3, name: "pop", kind: "message", T: ProofOfPossession },
    { no: 4, name: "btc_pk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "fp_btc_pk_list", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 6, name: "staking_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "staking_value", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "staking_tx", kind: "message", T: TransactionInfo },
    { no: 9, name: "slashing_tx", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 10, name: "delegator_slashing_sig", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 11, name: "unbonding_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 12, name: "unbonding_tx", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 13, name: "unbonding_value", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 14, name: "unbonding_slashing_tx", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 15, name: "delegator_unbonding_slashing_sig", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateBTCDelegation {
    return new MsgCreateBTCDelegation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateBTCDelegation {
    return new MsgCreateBTCDelegation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateBTCDelegation {
    return new MsgCreateBTCDelegation().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateBTCDelegation | PlainMessage<MsgCreateBTCDelegation> | undefined, b: MsgCreateBTCDelegation | PlainMessage<MsgCreateBTCDelegation> | undefined): boolean {
    return proto3.util.equals(MsgCreateBTCDelegation, a, b);
  }
}

/**
 * MsgCreateBTCDelegationResponse is the response for MsgCreateBTCDelegation
 *
 * @generated from message babylon.btcstaking.v1.MsgCreateBTCDelegationResponse
 */
export class MsgCreateBTCDelegationResponse extends Message<MsgCreateBTCDelegationResponse> {
  constructor(data?: PartialMessage<MsgCreateBTCDelegationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.MsgCreateBTCDelegationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateBTCDelegationResponse {
    return new MsgCreateBTCDelegationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateBTCDelegationResponse {
    return new MsgCreateBTCDelegationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateBTCDelegationResponse {
    return new MsgCreateBTCDelegationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateBTCDelegationResponse | PlainMessage<MsgCreateBTCDelegationResponse> | undefined, b: MsgCreateBTCDelegationResponse | PlainMessage<MsgCreateBTCDelegationResponse> | undefined): boolean {
    return proto3.util.equals(MsgCreateBTCDelegationResponse, a, b);
  }
}

/**
 * MsgAddCovenantSigs is the message for handling signatures from a covenant member
 *
 * @generated from message babylon.btcstaking.v1.MsgAddCovenantSigs
 */
export class MsgAddCovenantSigs extends Message<MsgAddCovenantSigs> {
  /**
   * @generated from field: string signer = 1;
   */
  signer = "";

  /**
   * pk is the BTC public key of the covenant member
   *
   * @generated from field: bytes pk = 2;
   */
  pk = new Uint8Array(0);

  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   *
   * @generated from field: string staking_tx_hash = 3;
   */
  stakingTxHash = "";

  /**
   * sigs is a list of adaptor signatures of the covenant
   * the order of sigs should respect the order of finality providers
   * of the corresponding delegation
   *
   * @generated from field: repeated bytes slashing_tx_sigs = 4;
   */
  slashingTxSigs: Uint8Array[] = [];

  /**
   * unbonding_tx_sig is the signature of the covenant on the unbonding tx submitted to babylon
   * the signature follows encoding in BIP-340 spec
   *
   * @generated from field: bytes unbonding_tx_sig = 5;
   */
  unbondingTxSig = new Uint8Array(0);

  /**
   * slashing_unbonding_tx_sigs is a list of adaptor signatures of the covenant
   * on slashing tx corresponding to unbonding tx submitted to babylon
   * the order of sigs should respect the order of finality providers
   * of the corresponding delegation
   *
   * @generated from field: repeated bytes slashing_unbonding_tx_sigs = 6;
   */
  slashingUnbondingTxSigs: Uint8Array[] = [];

  constructor(data?: PartialMessage<MsgAddCovenantSigs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.MsgAddCovenantSigs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "pk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "staking_tx_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "slashing_tx_sigs", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 5, name: "unbonding_tx_sig", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "slashing_unbonding_tx_sigs", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgAddCovenantSigs {
    return new MsgAddCovenantSigs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgAddCovenantSigs {
    return new MsgAddCovenantSigs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgAddCovenantSigs {
    return new MsgAddCovenantSigs().fromJsonString(jsonString, options);
  }

  static equals(a: MsgAddCovenantSigs | PlainMessage<MsgAddCovenantSigs> | undefined, b: MsgAddCovenantSigs | PlainMessage<MsgAddCovenantSigs> | undefined): boolean {
    return proto3.util.equals(MsgAddCovenantSigs, a, b);
  }
}

/**
 * MsgAddCovenantSigsResponse is the response for MsgAddCovenantSigs
 *
 * @generated from message babylon.btcstaking.v1.MsgAddCovenantSigsResponse
 */
export class MsgAddCovenantSigsResponse extends Message<MsgAddCovenantSigsResponse> {
  constructor(data?: PartialMessage<MsgAddCovenantSigsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.MsgAddCovenantSigsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgAddCovenantSigsResponse {
    return new MsgAddCovenantSigsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgAddCovenantSigsResponse {
    return new MsgAddCovenantSigsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgAddCovenantSigsResponse {
    return new MsgAddCovenantSigsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgAddCovenantSigsResponse | PlainMessage<MsgAddCovenantSigsResponse> | undefined, b: MsgAddCovenantSigsResponse | PlainMessage<MsgAddCovenantSigsResponse> | undefined): boolean {
    return proto3.util.equals(MsgAddCovenantSigsResponse, a, b);
  }
}

/**
 * MsgBTCUndelegate is the message for handling signature on unbonding tx
 * from its delegator. This signature effectively proves that the delegator
 * wants to unbond this BTC delegation
 *
 * @generated from message babylon.btcstaking.v1.MsgBTCUndelegate
 */
export class MsgBTCUndelegate extends Message<MsgBTCUndelegate> {
  /**
   * @generated from field: string signer = 1;
   */
  signer = "";

  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   *
   * @generated from field: string staking_tx_hash = 2;
   */
  stakingTxHash = "";

  /**
   * unbonding_tx_sig is the signature of the staker on the unbonding tx submitted to babylon
   * the signature follows encoding in BIP-340 spec
   *
   * @generated from field: bytes unbonding_tx_sig = 3;
   */
  unbondingTxSig = new Uint8Array(0);

  constructor(data?: PartialMessage<MsgBTCUndelegate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.MsgBTCUndelegate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "staking_tx_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "unbonding_tx_sig", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgBTCUndelegate {
    return new MsgBTCUndelegate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgBTCUndelegate {
    return new MsgBTCUndelegate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgBTCUndelegate {
    return new MsgBTCUndelegate().fromJsonString(jsonString, options);
  }

  static equals(a: MsgBTCUndelegate | PlainMessage<MsgBTCUndelegate> | undefined, b: MsgBTCUndelegate | PlainMessage<MsgBTCUndelegate> | undefined): boolean {
    return proto3.util.equals(MsgBTCUndelegate, a, b);
  }
}

/**
 * MsgBTCUndelegateResponse is the response for MsgBTCUndelegate
 *
 * @generated from message babylon.btcstaking.v1.MsgBTCUndelegateResponse
 */
export class MsgBTCUndelegateResponse extends Message<MsgBTCUndelegateResponse> {
  constructor(data?: PartialMessage<MsgBTCUndelegateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.MsgBTCUndelegateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgBTCUndelegateResponse {
    return new MsgBTCUndelegateResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgBTCUndelegateResponse {
    return new MsgBTCUndelegateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgBTCUndelegateResponse {
    return new MsgBTCUndelegateResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgBTCUndelegateResponse | PlainMessage<MsgBTCUndelegateResponse> | undefined, b: MsgBTCUndelegateResponse | PlainMessage<MsgBTCUndelegateResponse> | undefined): boolean {
    return proto3.util.equals(MsgBTCUndelegateResponse, a, b);
  }
}

/**
 * MsgSelectiveSlashingEvidence is the message for handling evidence of selective slashing
 * launched by a finality provider
 *
 * @generated from message babylon.btcstaking.v1.MsgSelectiveSlashingEvidence
 */
export class MsgSelectiveSlashingEvidence extends Message<MsgSelectiveSlashingEvidence> {
  /**
   * @generated from field: string signer = 1;
   */
  signer = "";

  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   *
   * @generated from field: string staking_tx_hash = 2;
   */
  stakingTxHash = "";

  /**
   * recovered_fp_btc_sk is the BTC SK of the finality provider who
   * launches the selective slashing offence. The SK is recovered by
   * using a covenant adaptor signature and the corresponding Schnorr
   * signature
   *
   * @generated from field: bytes recovered_fp_btc_sk = 3;
   */
  recoveredFpBtcSk = new Uint8Array(0);

  constructor(data?: PartialMessage<MsgSelectiveSlashingEvidence>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.MsgSelectiveSlashingEvidence";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "staking_tx_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "recovered_fp_btc_sk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSelectiveSlashingEvidence {
    return new MsgSelectiveSlashingEvidence().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSelectiveSlashingEvidence {
    return new MsgSelectiveSlashingEvidence().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSelectiveSlashingEvidence {
    return new MsgSelectiveSlashingEvidence().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSelectiveSlashingEvidence | PlainMessage<MsgSelectiveSlashingEvidence> | undefined, b: MsgSelectiveSlashingEvidence | PlainMessage<MsgSelectiveSlashingEvidence> | undefined): boolean {
    return proto3.util.equals(MsgSelectiveSlashingEvidence, a, b);
  }
}

/**
 * MsgSelectiveSlashingEvidenceResponse is the response for MsgSelectiveSlashingEvidence
 *
 * @generated from message babylon.btcstaking.v1.MsgSelectiveSlashingEvidenceResponse
 */
export class MsgSelectiveSlashingEvidenceResponse extends Message<MsgSelectiveSlashingEvidenceResponse> {
  constructor(data?: PartialMessage<MsgSelectiveSlashingEvidenceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.MsgSelectiveSlashingEvidenceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSelectiveSlashingEvidenceResponse {
    return new MsgSelectiveSlashingEvidenceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSelectiveSlashingEvidenceResponse {
    return new MsgSelectiveSlashingEvidenceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSelectiveSlashingEvidenceResponse {
    return new MsgSelectiveSlashingEvidenceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSelectiveSlashingEvidenceResponse | PlainMessage<MsgSelectiveSlashingEvidenceResponse> | undefined, b: MsgSelectiveSlashingEvidenceResponse | PlainMessage<MsgSelectiveSlashingEvidenceResponse> | undefined): boolean {
    return proto3.util.equals(MsgSelectiveSlashingEvidenceResponse, a, b);
  }
}

/**
 * MsgUpdateParams defines a message for updating btcstaking module parameters.
 *
 * @generated from message babylon.btcstaking.v1.MsgUpdateParams
 */
export class MsgUpdateParams extends Message<MsgUpdateParams> {
  /**
   * authority is the address of the governance account.
   * just FYI: cosmos.AddressString marks that this field should use type alias
   * for AddressString instead of string, but the functionality is not yet implemented
   * in cosmos-proto
   *
   * @generated from field: string authority = 1;
   */
  authority = "";

  /**
   * params defines the finality parameters to update.
   *
   * NOTE: All parameters must be supplied.
   *
   * @generated from field: babylon.btcstaking.v1.Params params = 2;
   */
  params?: Params;

  constructor(data?: PartialMessage<MsgUpdateParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.MsgUpdateParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "params", kind: "message", T: Params },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined, b: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined): boolean {
    return proto3.util.equals(MsgUpdateParams, a, b);
  }
}

/**
 * MsgUpdateParamsResponse is the response to the MsgUpdateParams message.
 *
 * @generated from message babylon.btcstaking.v1.MsgUpdateParamsResponse
 */
export class MsgUpdateParamsResponse extends Message<MsgUpdateParamsResponse> {
  constructor(data?: PartialMessage<MsgUpdateParamsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.MsgUpdateParamsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined, b: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateParamsResponse, a, b);
  }
}

