// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file babylon/btcstaking/v1/btcstaking.proto (package babylon.btcstaking.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Description } from "../../../cosmos/staking/v1beta1/staking_pb.js";
import { PubKey } from "../../../cosmos/crypto/secp256k1/keys_pb.js";
import { ProofOfPossession } from "./pop_pb.js";

/**
 * BTCDelegationStatus is the status of a delegation. The state transition path is
 * PENDING -> ACTIVE -> UNBONDED with two possibilities:
 * 1. the typical path when timelock of staking transaction expires.
 * 2. the path when staker requests early undelegation through MsgBTCUndelegate message.
 *
 * @generated from enum babylon.btcstaking.v1.BTCDelegationStatus
 */
export enum BTCDelegationStatus {
  /**
   * PENDING defines a delegation that is waiting for covenant signatures to become active.
   *
   * @generated from enum value: PENDING = 0;
   */
  PENDING = 0,

  /**
   * ACTIVE defines a delegation that has voting power
   *
   * @generated from enum value: ACTIVE = 1;
   */
  ACTIVE = 1,

  /**
   * UNBONDED defines a delegation no longer has voting power:
   * - either reaching the end of staking transaction timelock
   * - or receiving unbonding tx with signatures from staker and covenant committee
   *
   * @generated from enum value: UNBONDED = 2;
   */
  UNBONDED = 2,

  /**
   * ANY is any of the above status
   *
   * @generated from enum value: ANY = 3;
   */
  ANY = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(BTCDelegationStatus)
proto3.util.setEnumType(BTCDelegationStatus, "babylon.btcstaking.v1.BTCDelegationStatus", [
  { no: 0, name: "PENDING" },
  { no: 1, name: "ACTIVE" },
  { no: 2, name: "UNBONDED" },
  { no: 3, name: "ANY" },
]);

/**
 * FinalityProvider defines a finality provider
 *
 * @generated from message babylon.btcstaking.v1.FinalityProvider
 */
export class FinalityProvider extends Message<FinalityProvider> {
  /**
   * description defines the description terms for the finality provider.
   *
   * @generated from field: cosmos.staking.v1beta1.Description description = 1;
   */
  description?: Description;

  /**
   * commission defines the commission rate of the finality provider.
   *
   * @generated from field: string commission = 2;
   */
  commission = "";

  /**
   * babylon_pk is the Babylon secp256k1 PK of this finality provider
   *
   * @generated from field: cosmos.crypto.secp256k1.PubKey babylon_pk = 3;
   */
  babylonPk?: PubKey;

  /**
   * btc_pk is the Bitcoin secp256k1 PK of this finality provider
   * the PK follows encoding in BIP-340 spec
   *
   * @generated from field: bytes btc_pk = 4;
   */
  btcPk = new Uint8Array(0);

  /**
   * pop is the proof of possession of babylon_pk and btc_pk
   *
   * @generated from field: babylon.btcstaking.v1.ProofOfPossession pop = 5;
   */
  pop?: ProofOfPossession;

  /**
   * slashed_babylon_height indicates the Babylon height when
   * the finality provider is slashed.
   * if it's 0 then the finality provider is not slashed
   *
   * @generated from field: uint64 slashed_babylon_height = 6;
   */
  slashedBabylonHeight = protoInt64.zero;

  /**
   * slashed_btc_height indicates the BTC height when
   * the finality provider is slashed.
   * if it's 0 then the finality provider is not slashed
   *
   * @generated from field: uint64 slashed_btc_height = 7;
   */
  slashedBtcHeight = protoInt64.zero;

  constructor(data?: PartialMessage<FinalityProvider>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.FinalityProvider";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "description", kind: "message", T: Description },
    { no: 2, name: "commission", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "babylon_pk", kind: "message", T: PubKey },
    { no: 4, name: "btc_pk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "pop", kind: "message", T: ProofOfPossession },
    { no: 6, name: "slashed_babylon_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "slashed_btc_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FinalityProvider {
    return new FinalityProvider().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FinalityProvider {
    return new FinalityProvider().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FinalityProvider {
    return new FinalityProvider().fromJsonString(jsonString, options);
  }

  static equals(a: FinalityProvider | PlainMessage<FinalityProvider> | undefined, b: FinalityProvider | PlainMessage<FinalityProvider> | undefined): boolean {
    return proto3.util.equals(FinalityProvider, a, b);
  }
}

/**
 * FinalityProviderWithMeta wraps the FinalityProvider with metadata.
 *
 * @generated from message babylon.btcstaking.v1.FinalityProviderWithMeta
 */
export class FinalityProviderWithMeta extends Message<FinalityProviderWithMeta> {
  /**
   * btc_pk is the Bitcoin secp256k1 PK of thisfinality provider
   * the PK follows encoding in BIP-340 spec
   *
   * @generated from field: bytes btc_pk = 1;
   */
  btcPk = new Uint8Array(0);

  /**
   * height is the queried Babylon height
   *
   * @generated from field: uint64 height = 2;
   */
  height = protoInt64.zero;

  /**
   * voting_power is the voting power of this finality provider at the given height
   *
   * @generated from field: uint64 voting_power = 3;
   */
  votingPower = protoInt64.zero;

  /**
   * slashed_babylon_height indicates the Babylon height when
   * the finality provider is slashed.
   * if it's 0 then the finality provider is not slashed
   *
   * @generated from field: uint64 slashed_babylon_height = 4;
   */
  slashedBabylonHeight = protoInt64.zero;

  /**
   * slashed_btc_height indicates the BTC height when
   * the finality provider is slashed.
   * if it's 0 then the finality provider is not slashed
   *
   * @generated from field: uint64 slashed_btc_height = 5;
   */
  slashedBtcHeight = protoInt64.zero;

  constructor(data?: PartialMessage<FinalityProviderWithMeta>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.FinalityProviderWithMeta";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "btc_pk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "voting_power", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "slashed_babylon_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "slashed_btc_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FinalityProviderWithMeta {
    return new FinalityProviderWithMeta().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FinalityProviderWithMeta {
    return new FinalityProviderWithMeta().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FinalityProviderWithMeta {
    return new FinalityProviderWithMeta().fromJsonString(jsonString, options);
  }

  static equals(a: FinalityProviderWithMeta | PlainMessage<FinalityProviderWithMeta> | undefined, b: FinalityProviderWithMeta | PlainMessage<FinalityProviderWithMeta> | undefined): boolean {
    return proto3.util.equals(FinalityProviderWithMeta, a, b);
  }
}

/**
 * BTCDelegation defines a BTC delegation
 *
 * @generated from message babylon.btcstaking.v1.BTCDelegation
 */
export class BTCDelegation extends Message<BTCDelegation> {
  /**
   * babylon_pk is the Babylon secp256k1 PK of this BTC delegation
   *
   * @generated from field: cosmos.crypto.secp256k1.PubKey babylon_pk = 1;
   */
  babylonPk?: PubKey;

  /**
   * btc_pk is the Bitcoin secp256k1 PK of this BTC delegation
   * the PK follows encoding in BIP-340 spec
   *
   * @generated from field: bytes btc_pk = 2;
   */
  btcPk = new Uint8Array(0);

  /**
   * pop is the proof of possession of babylon_pk and btc_pk
   *
   * @generated from field: babylon.btcstaking.v1.ProofOfPossession pop = 3;
   */
  pop?: ProofOfPossession;

  /**
   * fp_btc_pk_list is the list of BIP-340 PKs of the finality providers that
   * this BTC delegation delegates to
   * If there is more than 1 PKs, then this means the delegation is restaked
   * to multiple finality providers
   *
   * @generated from field: repeated bytes fp_btc_pk_list = 4;
   */
  fpBtcPkList: Uint8Array[] = [];

  /**
   * start_height is the start BTC height of the BTC delegation
   * it is the start BTC height of the timelock
   *
   * @generated from field: uint64 start_height = 5;
   */
  startHeight = protoInt64.zero;

  /**
   * end_height is the end height of the BTC delegation
   * it is the end BTC height of the timelock - w
   *
   * @generated from field: uint64 end_height = 6;
   */
  endHeight = protoInt64.zero;

  /**
   * total_sat is the total amount of BTC stakes in this delegation
   * quantified in satoshi
   *
   * @generated from field: uint64 total_sat = 7;
   */
  totalSat = protoInt64.zero;

  /**
   * staking_tx is the staking tx
   *
   * @generated from field: bytes staking_tx = 8;
   */
  stakingTx = new Uint8Array(0);

  /**
   * staking_output_idx is the index of the staking output in the staking tx
   *
   * @generated from field: uint32 staking_output_idx = 9;
   */
  stakingOutputIdx = 0;

  /**
   * slashing_tx is the slashing tx
   * It is partially signed by SK corresponding to btc_pk, but not signed by
   * finality provider or covenant yet.
   *
   * @generated from field: bytes slashing_tx = 10;
   */
  slashingTx = new Uint8Array(0);

  /**
   * delegator_sig is the signature on the slashing tx
   * by the delegator (i.e., SK corresponding to btc_pk).
   * It will be a part of the witness for the staking tx output.
   *
   * @generated from field: bytes delegator_sig = 11;
   */
  delegatorSig = new Uint8Array(0);

  /**
   * covenant_sigs is a list of adaptor signatures on the slashing tx
   * by each covenant member
   * It will be a part of the witness for the staking tx output.
   *
   * @generated from field: repeated babylon.btcstaking.v1.CovenantAdaptorSignatures covenant_sigs = 12;
   */
  covenantSigs: CovenantAdaptorSignatures[] = [];

  /**
   * unbonding_time describes how long the funds will be locked either in unbonding output
   * or slashing change output
   *
   * @generated from field: uint32 unbonding_time = 13;
   */
  unbondingTime = 0;

  /**
   * btc_undelegation is the information about the early unbonding path of the BTC delegation
   *
   * @generated from field: babylon.btcstaking.v1.BTCUndelegation btc_undelegation = 14;
   */
  btcUndelegation?: BTCUndelegation;

  constructor(data?: PartialMessage<BTCDelegation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.BTCDelegation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "babylon_pk", kind: "message", T: PubKey },
    { no: 2, name: "btc_pk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "pop", kind: "message", T: ProofOfPossession },
    { no: 4, name: "fp_btc_pk_list", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 5, name: "start_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "end_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "total_sat", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 8, name: "staking_tx", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "staking_output_idx", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 10, name: "slashing_tx", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 11, name: "delegator_sig", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 12, name: "covenant_sigs", kind: "message", T: CovenantAdaptorSignatures, repeated: true },
    { no: 13, name: "unbonding_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 14, name: "btc_undelegation", kind: "message", T: BTCUndelegation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BTCDelegation {
    return new BTCDelegation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BTCDelegation {
    return new BTCDelegation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BTCDelegation {
    return new BTCDelegation().fromJsonString(jsonString, options);
  }

  static equals(a: BTCDelegation | PlainMessage<BTCDelegation> | undefined, b: BTCDelegation | PlainMessage<BTCDelegation> | undefined): boolean {
    return proto3.util.equals(BTCDelegation, a, b);
  }
}

/**
 * BTCUndelegation contains the information about the early unbonding path of the BTC delegation
 *
 * @generated from message babylon.btcstaking.v1.BTCUndelegation
 */
export class BTCUndelegation extends Message<BTCUndelegation> {
  /**
   * unbonding_tx is the transaction which will transfer the funds from staking
   * output to unbonding output. Unbonding output will usually have lower timelock
   * than staking output.
   *
   * @generated from field: bytes unbonding_tx = 1;
   */
  unbondingTx = new Uint8Array(0);

  /**
   * slashing_tx is the slashing tx for unbonding transactions
   * It is partially signed by SK corresponding to btc_pk, but not signed by
   * finality provider or covenant yet.
   *
   * @generated from field: bytes slashing_tx = 2;
   */
  slashingTx = new Uint8Array(0);

  /**
   * delegator_unbonding_sig is the signature on the unbonding tx
   * by the delegator (i.e., SK corresponding to btc_pk).
   * It effectively proves that the delegator wants to unbond and thus
   * Babylon will consider this BTC delegation unbonded. Delegator's BTC
   * on Bitcoin will be unbonded after timelock
   *
   * @generated from field: bytes delegator_unbonding_sig = 3;
   */
  delegatorUnbondingSig = new Uint8Array(0);

  /**
   * delegator_slashing_sig is the signature on the slashing tx
   * by the delegator (i.e., SK corresponding to btc_pk).
   * It will be a part of the witness for the unbonding tx output.
   *
   * @generated from field: bytes delegator_slashing_sig = 4;
   */
  delegatorSlashingSig = new Uint8Array(0);

  /**
   * covenant_slashing_sigs is a list of adaptor signatures on the slashing tx
   * by each covenant member
   * It will be a part of the witness for the staking tx output.
   *
   * @generated from field: repeated babylon.btcstaking.v1.CovenantAdaptorSignatures covenant_slashing_sigs = 5;
   */
  covenantSlashingSigs: CovenantAdaptorSignatures[] = [];

  /**
   * covenant_unbonding_sig_list is the list of signatures on the unbonding tx
   * by covenant members
   * It must be provided after processing undelegate message by Babylon
   *
   * @generated from field: repeated babylon.btcstaking.v1.SignatureInfo covenant_unbonding_sig_list = 6;
   */
  covenantUnbondingSigList: SignatureInfo[] = [];

  constructor(data?: PartialMessage<BTCUndelegation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.BTCUndelegation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "unbonding_tx", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "slashing_tx", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "delegator_unbonding_sig", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "delegator_slashing_sig", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "covenant_slashing_sigs", kind: "message", T: CovenantAdaptorSignatures, repeated: true },
    { no: 6, name: "covenant_unbonding_sig_list", kind: "message", T: SignatureInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BTCUndelegation {
    return new BTCUndelegation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BTCUndelegation {
    return new BTCUndelegation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BTCUndelegation {
    return new BTCUndelegation().fromJsonString(jsonString, options);
  }

  static equals(a: BTCUndelegation | PlainMessage<BTCUndelegation> | undefined, b: BTCUndelegation | PlainMessage<BTCUndelegation> | undefined): boolean {
    return proto3.util.equals(BTCUndelegation, a, b);
  }
}

/**
 * BTCDelegatorDelegations is a collection of BTC delegations from the same delegator.
 *
 * @generated from message babylon.btcstaking.v1.BTCDelegatorDelegations
 */
export class BTCDelegatorDelegations extends Message<BTCDelegatorDelegations> {
  /**
   * @generated from field: repeated babylon.btcstaking.v1.BTCDelegation dels = 1;
   */
  dels: BTCDelegation[] = [];

  constructor(data?: PartialMessage<BTCDelegatorDelegations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.BTCDelegatorDelegations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "dels", kind: "message", T: BTCDelegation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BTCDelegatorDelegations {
    return new BTCDelegatorDelegations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BTCDelegatorDelegations {
    return new BTCDelegatorDelegations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BTCDelegatorDelegations {
    return new BTCDelegatorDelegations().fromJsonString(jsonString, options);
  }

  static equals(a: BTCDelegatorDelegations | PlainMessage<BTCDelegatorDelegations> | undefined, b: BTCDelegatorDelegations | PlainMessage<BTCDelegatorDelegations> | undefined): boolean {
    return proto3.util.equals(BTCDelegatorDelegations, a, b);
  }
}

/**
 * BTCDelegatorDelegationIndex is a list of staking tx hashes of BTC delegations from the same delegator.
 *
 * @generated from message babylon.btcstaking.v1.BTCDelegatorDelegationIndex
 */
export class BTCDelegatorDelegationIndex extends Message<BTCDelegatorDelegationIndex> {
  /**
   * @generated from field: repeated bytes staking_tx_hash_list = 1;
   */
  stakingTxHashList: Uint8Array[] = [];

  constructor(data?: PartialMessage<BTCDelegatorDelegationIndex>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.BTCDelegatorDelegationIndex";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "staking_tx_hash_list", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BTCDelegatorDelegationIndex {
    return new BTCDelegatorDelegationIndex().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BTCDelegatorDelegationIndex {
    return new BTCDelegatorDelegationIndex().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BTCDelegatorDelegationIndex {
    return new BTCDelegatorDelegationIndex().fromJsonString(jsonString, options);
  }

  static equals(a: BTCDelegatorDelegationIndex | PlainMessage<BTCDelegatorDelegationIndex> | undefined, b: BTCDelegatorDelegationIndex | PlainMessage<BTCDelegatorDelegationIndex> | undefined): boolean {
    return proto3.util.equals(BTCDelegatorDelegationIndex, a, b);
  }
}

/**
 * SignatureInfo is a BIP-340 signature together with its signer's BIP-340 PK
 *
 * @generated from message babylon.btcstaking.v1.SignatureInfo
 */
export class SignatureInfo extends Message<SignatureInfo> {
  /**
   * @generated from field: bytes pk = 1;
   */
  pk = new Uint8Array(0);

  /**
   * @generated from field: bytes sig = 2;
   */
  sig = new Uint8Array(0);

  constructor(data?: PartialMessage<SignatureInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.SignatureInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "sig", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignatureInfo {
    return new SignatureInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignatureInfo {
    return new SignatureInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignatureInfo {
    return new SignatureInfo().fromJsonString(jsonString, options);
  }

  static equals(a: SignatureInfo | PlainMessage<SignatureInfo> | undefined, b: SignatureInfo | PlainMessage<SignatureInfo> | undefined): boolean {
    return proto3.util.equals(SignatureInfo, a, b);
  }
}

/**
 * CovenantAdaptorSignatures is a list adaptor signatures signed by the
 * covenant with different finality provider's public keys as encryption keys
 *
 * @generated from message babylon.btcstaking.v1.CovenantAdaptorSignatures
 */
export class CovenantAdaptorSignatures extends Message<CovenantAdaptorSignatures> {
  /**
   * cov_pk is the public key of the covenant emulator, used as the public key of the adaptor signature
   *
   * @generated from field: bytes cov_pk = 1;
   */
  covPk = new Uint8Array(0);

  /**
   * adaptor_sigs is a list of adaptor signatures, each encrypted by a restaked BTC finality provider's public key
   *
   * @generated from field: repeated bytes adaptor_sigs = 2;
   */
  adaptorSigs: Uint8Array[] = [];

  constructor(data?: PartialMessage<CovenantAdaptorSignatures>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.CovenantAdaptorSignatures";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cov_pk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "adaptor_sigs", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CovenantAdaptorSignatures {
    return new CovenantAdaptorSignatures().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CovenantAdaptorSignatures {
    return new CovenantAdaptorSignatures().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CovenantAdaptorSignatures {
    return new CovenantAdaptorSignatures().fromJsonString(jsonString, options);
  }

  static equals(a: CovenantAdaptorSignatures | PlainMessage<CovenantAdaptorSignatures> | undefined, b: CovenantAdaptorSignatures | PlainMessage<CovenantAdaptorSignatures> | undefined): boolean {
    return proto3.util.equals(CovenantAdaptorSignatures, a, b);
  }
}

/**
 * SelectiveSlashingEvidence is the evidence that the finality provider
 * selectively slashed a BTC delegation
 * NOTE: it's possible that a slashed finality provider exploits the
 * SelectiveSlashingEvidence endpoint while it is actually slashed due to
 * equivocation. But such behaviour does not affect the system's security
 * or gives any benefit for the adversary
 *
 * @generated from message babylon.btcstaking.v1.SelectiveSlashingEvidence
 */
export class SelectiveSlashingEvidence extends Message<SelectiveSlashingEvidence> {
  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   *
   * @generated from field: string staking_tx_hash = 1;
   */
  stakingTxHash = "";

  /**
   * fp_btc_pk is the BTC PK of the finality provider who
   * launches the selective slashing offence
   *
   * @generated from field: bytes fp_btc_pk = 2;
   */
  fpBtcPk = new Uint8Array(0);

  /**
   * recovered_fp_btc_sk is the finality provider's BTC SK recovered from
   * the covenant adaptor/Schnorr signature pair. It is the consequence
   * of selective slashing.
   *
   * @generated from field: bytes recovered_fp_btc_sk = 3;
   */
  recoveredFpBtcSk = new Uint8Array(0);

  constructor(data?: PartialMessage<SelectiveSlashingEvidence>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.SelectiveSlashingEvidence";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "staking_tx_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "fp_btc_pk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "recovered_fp_btc_sk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SelectiveSlashingEvidence {
    return new SelectiveSlashingEvidence().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SelectiveSlashingEvidence {
    return new SelectiveSlashingEvidence().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SelectiveSlashingEvidence {
    return new SelectiveSlashingEvidence().fromJsonString(jsonString, options);
  }

  static equals(a: SelectiveSlashingEvidence | PlainMessage<SelectiveSlashingEvidence> | undefined, b: SelectiveSlashingEvidence | PlainMessage<SelectiveSlashingEvidence> | undefined): boolean {
    return proto3.util.equals(SelectiveSlashingEvidence, a, b);
  }
}

