// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file babylon/btcstaking/v1/genesis.proto (package babylon.btcstaking.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Params } from "./params_pb.js";
import { BTCDelegation, BTCDelegatorDelegationIndex, FinalityProvider } from "./btcstaking_pb.js";
import { VotingPowerDistCache } from "./incentive_pb.js";
import { EventPowerDistUpdate } from "./events_pb.js";

/**
 * GenesisState defines the btcstaking module's genesis state.
 *
 * @generated from message babylon.btcstaking.v1.GenesisState
 */
export class GenesisState extends Message<GenesisState> {
  /**
   * @generated from field: babylon.btcstaking.v1.Params params = 1;
   */
  params?: Params;

  /**
   * finality_providers all the finality providers registered.
   *
   * @generated from field: repeated babylon.btcstaking.v1.FinalityProvider finality_providers = 2;
   */
  finalityProviders: FinalityProvider[] = [];

  /**
   * btc_delegations all the btc delegations in the state.
   *
   * @generated from field: repeated babylon.btcstaking.v1.BTCDelegation btc_delegations = 3;
   */
  btcDelegations: BTCDelegation[] = [];

  /**
   * voting_powers the voting power of every finality provider at every block height.
   *
   * @generated from field: repeated babylon.btcstaking.v1.VotingPowerFP voting_powers = 4;
   */
  votingPowers: VotingPowerFP[] = [];

  /**
   * block_height_chains the block height of babylon and bitcoin.
   *
   * @generated from field: repeated babylon.btcstaking.v1.BlockHeightBbnToBtc block_height_chains = 5;
   */
  blockHeightChains: BlockHeightBbnToBtc[] = [];

  /**
   * btc_delegators contains all the btc delegators with the associated finality provider.
   *
   * @generated from field: repeated babylon.btcstaking.v1.BTCDelegator btc_delegators = 6;
   */
  btcDelegators: BTCDelegator[] = [];

  /**
   * all the events and its indexes.
   *
   * @generated from field: repeated babylon.btcstaking.v1.EventIndex events = 7;
   */
  events: EventIndex[] = [];

  /**
   * vp_dst_cache is the table of all providers voting power with the total at one specific block.
   * TODO: remove this after not storing in the keeper store it anymore.
   *
   * @generated from field: repeated babylon.btcstaking.v1.VotingPowerDistCacheBlkHeight vp_dst_cache = 8;
   */
  vpDstCache: VotingPowerDistCacheBlkHeight[] = [];

  constructor(data?: PartialMessage<GenesisState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.GenesisState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: Params },
    { no: 2, name: "finality_providers", kind: "message", T: FinalityProvider, repeated: true },
    { no: 3, name: "btc_delegations", kind: "message", T: BTCDelegation, repeated: true },
    { no: 4, name: "voting_powers", kind: "message", T: VotingPowerFP, repeated: true },
    { no: 5, name: "block_height_chains", kind: "message", T: BlockHeightBbnToBtc, repeated: true },
    { no: 6, name: "btc_delegators", kind: "message", T: BTCDelegator, repeated: true },
    { no: 7, name: "events", kind: "message", T: EventIndex, repeated: true },
    { no: 8, name: "vp_dst_cache", kind: "message", T: VotingPowerDistCacheBlkHeight, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenesisState {
    return new GenesisState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenesisState {
    return new GenesisState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenesisState {
    return new GenesisState().fromJsonString(jsonString, options);
  }

  static equals(a: GenesisState | PlainMessage<GenesisState> | undefined, b: GenesisState | PlainMessage<GenesisState> | undefined): boolean {
    return proto3.util.equals(GenesisState, a, b);
  }
}

/**
 * VotingPowerFP contains the information about the voting power
 * of an finality provider in a specific block height.
 *
 * @generated from message babylon.btcstaking.v1.VotingPowerFP
 */
export class VotingPowerFP extends Message<VotingPowerFP> {
  /**
   * block_height is the height of the block the voting power was stored.
   *
   * @generated from field: uint64 block_height = 1;
   */
  blockHeight = protoInt64.zero;

  /**
   * fp_btc_pk the finality provider btc public key.
   *
   * @generated from field: bytes fp_btc_pk = 2;
   */
  fpBtcPk = new Uint8Array(0);

  /**
   * voting_power is the power of the finality provider at this specific block height.
   *
   * @generated from field: uint64 voting_power = 3;
   */
  votingPower = protoInt64.zero;

  constructor(data?: PartialMessage<VotingPowerFP>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.VotingPowerFP";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "block_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "fp_btc_pk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "voting_power", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VotingPowerFP {
    return new VotingPowerFP().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VotingPowerFP {
    return new VotingPowerFP().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VotingPowerFP {
    return new VotingPowerFP().fromJsonString(jsonString, options);
  }

  static equals(a: VotingPowerFP | PlainMessage<VotingPowerFP> | undefined, b: VotingPowerFP | PlainMessage<VotingPowerFP> | undefined): boolean {
    return proto3.util.equals(VotingPowerFP, a, b);
  }
}

/**
 * VotingPowerDistCacheBlkHeight the total voting power of the finality providers at one specific block height
 *
 * @generated from message babylon.btcstaking.v1.VotingPowerDistCacheBlkHeight
 */
export class VotingPowerDistCacheBlkHeight extends Message<VotingPowerDistCacheBlkHeight> {
  /**
   * block_height is the height of the block the voting power distribution cached was stored.
   *
   * @generated from field: uint64 block_height = 1;
   */
  blockHeight = protoInt64.zero;

  /**
   * vp_distribution the finality providers distribution cache at that height.
   *
   * @generated from field: babylon.btcstaking.v1.VotingPowerDistCache vp_distribution = 2;
   */
  vpDistribution?: VotingPowerDistCache;

  constructor(data?: PartialMessage<VotingPowerDistCacheBlkHeight>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.VotingPowerDistCacheBlkHeight";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "block_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "vp_distribution", kind: "message", T: VotingPowerDistCache },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VotingPowerDistCacheBlkHeight {
    return new VotingPowerDistCacheBlkHeight().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VotingPowerDistCacheBlkHeight {
    return new VotingPowerDistCacheBlkHeight().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VotingPowerDistCacheBlkHeight {
    return new VotingPowerDistCacheBlkHeight().fromJsonString(jsonString, options);
  }

  static equals(a: VotingPowerDistCacheBlkHeight | PlainMessage<VotingPowerDistCacheBlkHeight> | undefined, b: VotingPowerDistCacheBlkHeight | PlainMessage<VotingPowerDistCacheBlkHeight> | undefined): boolean {
    return proto3.util.equals(VotingPowerDistCacheBlkHeight, a, b);
  }
}

/**
 * BlockHeightBbnToBtc stores the btc <-> bbn block.
 *
 * @generated from message babylon.btcstaking.v1.BlockHeightBbnToBtc
 */
export class BlockHeightBbnToBtc extends Message<BlockHeightBbnToBtc> {
  /**
   * block_height_bbn is the height of the block in the babylon chain.
   *
   * @generated from field: uint64 block_height_bbn = 1;
   */
  blockHeightBbn = protoInt64.zero;

  /**
   * block_height_btc is the height of the block in the BTC.
   *
   * @generated from field: uint64 block_height_btc = 2;
   */
  blockHeightBtc = protoInt64.zero;

  constructor(data?: PartialMessage<BlockHeightBbnToBtc>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.BlockHeightBbnToBtc";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "block_height_bbn", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "block_height_btc", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlockHeightBbnToBtc {
    return new BlockHeightBbnToBtc().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlockHeightBbnToBtc {
    return new BlockHeightBbnToBtc().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlockHeightBbnToBtc {
    return new BlockHeightBbnToBtc().fromJsonString(jsonString, options);
  }

  static equals(a: BlockHeightBbnToBtc | PlainMessage<BlockHeightBbnToBtc> | undefined, b: BlockHeightBbnToBtc | PlainMessage<BlockHeightBbnToBtc> | undefined): boolean {
    return proto3.util.equals(BlockHeightBbnToBtc, a, b);
  }
}

/**
 * BTCDelegator BTC delegator information with the associated finality provider.
 *
 * @generated from message babylon.btcstaking.v1.BTCDelegator
 */
export class BTCDelegator extends Message<BTCDelegator> {
  /**
   * idx the btc delegator index.
   *
   * @generated from field: babylon.btcstaking.v1.BTCDelegatorDelegationIndex idx = 1;
   */
  idx?: BTCDelegatorDelegationIndex;

  /**
   * fp_btc_pk the finality provider btc public key.
   *
   * @generated from field: bytes fp_btc_pk = 2;
   */
  fpBtcPk = new Uint8Array(0);

  /**
   * del_btc_pk the delegator btc public key.
   *
   * @generated from field: bytes del_btc_pk = 3;
   */
  delBtcPk = new Uint8Array(0);

  constructor(data?: PartialMessage<BTCDelegator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.BTCDelegator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "idx", kind: "message", T: BTCDelegatorDelegationIndex },
    { no: 2, name: "fp_btc_pk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "del_btc_pk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BTCDelegator {
    return new BTCDelegator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BTCDelegator {
    return new BTCDelegator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BTCDelegator {
    return new BTCDelegator().fromJsonString(jsonString, options);
  }

  static equals(a: BTCDelegator | PlainMessage<BTCDelegator> | undefined, b: BTCDelegator | PlainMessage<BTCDelegator> | undefined): boolean {
    return proto3.util.equals(BTCDelegator, a, b);
  }
}

/**
 * EventIndex contains the event and its index.
 *
 * @generated from message babylon.btcstaking.v1.EventIndex
 */
export class EventIndex extends Message<EventIndex> {
  /**
   * idx is the index the event was stored.
   *
   * @generated from field: uint64 idx = 1;
   */
  idx = protoInt64.zero;

  /**
   * block_height_btc is the height of the block in the BTC chain.
   *
   * @generated from field: uint64 block_height_btc = 2;
   */
  blockHeightBtc = protoInt64.zero;

  /**
   * event the event stored.
   *
   * @generated from field: babylon.btcstaking.v1.EventPowerDistUpdate event = 3;
   */
  event?: EventPowerDistUpdate;

  constructor(data?: PartialMessage<EventIndex>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btcstaking.v1.EventIndex";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "idx", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "block_height_btc", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "event", kind: "message", T: EventPowerDistUpdate },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventIndex {
    return new EventIndex().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventIndex {
    return new EventIndex().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventIndex {
    return new EventIndex().fromJsonString(jsonString, options);
  }

  static equals(a: EventIndex | PlainMessage<EventIndex> | undefined, b: EventIndex | PlainMessage<EventIndex> | undefined): boolean {
    return proto3.util.equals(EventIndex, a, b);
  }
}

