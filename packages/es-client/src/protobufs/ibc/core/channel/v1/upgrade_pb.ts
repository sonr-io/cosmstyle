// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file ibc/core/channel/v1/upgrade.proto (package ibc.core.channel.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Order, Timeout } from "./channel_pb.js";

/**
 * Upgrade is a verifiable type which contains the relevant information
 * for an attempted upgrade. It provides the proposed changes to the channel
 * end, the timeout for this upgrade attempt and the next packet sequence
 * which allows the counterparty to efficiently know the highest sequence it has received.
 * The next sequence send is used for pruning and upgrading from unordered to ordered channels.
 *
 * @generated from message ibc.core.channel.v1.Upgrade
 */
export class Upgrade extends Message<Upgrade> {
  /**
   * @generated from field: ibc.core.channel.v1.UpgradeFields fields = 1;
   */
  fields?: UpgradeFields;

  /**
   * @generated from field: ibc.core.channel.v1.Timeout timeout = 2;
   */
  timeout?: Timeout;

  /**
   * @generated from field: uint64 next_sequence_send = 3;
   */
  nextSequenceSend = protoInt64.zero;

  constructor(data?: PartialMessage<Upgrade>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.channel.v1.Upgrade";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fields", kind: "message", T: UpgradeFields },
    { no: 2, name: "timeout", kind: "message", T: Timeout },
    { no: 3, name: "next_sequence_send", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Upgrade {
    return new Upgrade().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Upgrade {
    return new Upgrade().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Upgrade {
    return new Upgrade().fromJsonString(jsonString, options);
  }

  static equals(a: Upgrade | PlainMessage<Upgrade> | undefined, b: Upgrade | PlainMessage<Upgrade> | undefined): boolean {
    return proto3.util.equals(Upgrade, a, b);
  }
}

/**
 * UpgradeFields are the fields in a channel end which may be changed
 * during a channel upgrade.
 *
 * @generated from message ibc.core.channel.v1.UpgradeFields
 */
export class UpgradeFields extends Message<UpgradeFields> {
  /**
   * @generated from field: ibc.core.channel.v1.Order ordering = 1;
   */
  ordering = Order.NONE_UNSPECIFIED;

  /**
   * @generated from field: repeated string connection_hops = 2;
   */
  connectionHops: string[] = [];

  /**
   * @generated from field: string version = 3;
   */
  version = "";

  constructor(data?: PartialMessage<UpgradeFields>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.channel.v1.UpgradeFields";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ordering", kind: "enum", T: proto3.getEnumType(Order) },
    { no: 2, name: "connection_hops", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpgradeFields {
    return new UpgradeFields().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpgradeFields {
    return new UpgradeFields().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpgradeFields {
    return new UpgradeFields().fromJsonString(jsonString, options);
  }

  static equals(a: UpgradeFields | PlainMessage<UpgradeFields> | undefined, b: UpgradeFields | PlainMessage<UpgradeFields> | undefined): boolean {
    return proto3.util.equals(UpgradeFields, a, b);
  }
}

/**
 * ErrorReceipt defines a type which encapsulates the upgrade sequence and error associated with the
 * upgrade handshake failure. When a channel upgrade handshake is aborted both chains are expected to increment to the
 * next sequence.
 *
 * @generated from message ibc.core.channel.v1.ErrorReceipt
 */
export class ErrorReceipt extends Message<ErrorReceipt> {
  /**
   * the channel upgrade sequence
   *
   * @generated from field: uint64 sequence = 1;
   */
  sequence = protoInt64.zero;

  /**
   * the error message detailing the cause of failure
   *
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<ErrorReceipt>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.channel.v1.ErrorReceipt";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sequence", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorReceipt {
    return new ErrorReceipt().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorReceipt {
    return new ErrorReceipt().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorReceipt {
    return new ErrorReceipt().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorReceipt | PlainMessage<ErrorReceipt> | undefined, b: ErrorReceipt | PlainMessage<ErrorReceipt> | undefined): boolean {
    return proto3.util.equals(ErrorReceipt, a, b);
  }
}

