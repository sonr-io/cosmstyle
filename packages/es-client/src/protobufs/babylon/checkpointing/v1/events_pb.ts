// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file babylon/checkpointing/v1/events.proto (package babylon.checkpointing.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { RawCheckpoint, RawCheckpointWithMeta } from "./checkpoint_pb.js";

/**
 * EventCheckpointAccumulating is emitted when a checkpoint reaches the
 * `Accumulating` state.
 *
 * @generated from message babylon.checkpointing.v1.EventCheckpointAccumulating
 */
export class EventCheckpointAccumulating extends Message<EventCheckpointAccumulating> {
  /**
   * @generated from field: babylon.checkpointing.v1.RawCheckpointWithMeta checkpoint = 1;
   */
  checkpoint?: RawCheckpointWithMeta;

  constructor(data?: PartialMessage<EventCheckpointAccumulating>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.checkpointing.v1.EventCheckpointAccumulating";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "checkpoint", kind: "message", T: RawCheckpointWithMeta },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventCheckpointAccumulating {
    return new EventCheckpointAccumulating().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventCheckpointAccumulating {
    return new EventCheckpointAccumulating().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventCheckpointAccumulating {
    return new EventCheckpointAccumulating().fromJsonString(jsonString, options);
  }

  static equals(a: EventCheckpointAccumulating | PlainMessage<EventCheckpointAccumulating> | undefined, b: EventCheckpointAccumulating | PlainMessage<EventCheckpointAccumulating> | undefined): boolean {
    return proto3.util.equals(EventCheckpointAccumulating, a, b);
  }
}

/**
 * EventCheckpointSealed is emitted when a checkpoint reaches the `Sealed`
 * state.
 *
 * @generated from message babylon.checkpointing.v1.EventCheckpointSealed
 */
export class EventCheckpointSealed extends Message<EventCheckpointSealed> {
  /**
   * @generated from field: babylon.checkpointing.v1.RawCheckpointWithMeta checkpoint = 1;
   */
  checkpoint?: RawCheckpointWithMeta;

  constructor(data?: PartialMessage<EventCheckpointSealed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.checkpointing.v1.EventCheckpointSealed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "checkpoint", kind: "message", T: RawCheckpointWithMeta },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventCheckpointSealed {
    return new EventCheckpointSealed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventCheckpointSealed {
    return new EventCheckpointSealed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventCheckpointSealed {
    return new EventCheckpointSealed().fromJsonString(jsonString, options);
  }

  static equals(a: EventCheckpointSealed | PlainMessage<EventCheckpointSealed> | undefined, b: EventCheckpointSealed | PlainMessage<EventCheckpointSealed> | undefined): boolean {
    return proto3.util.equals(EventCheckpointSealed, a, b);
  }
}

/**
 * EventCheckpointSubmitted is emitted when a checkpoint reaches the `Submitted`
 * state.
 *
 * @generated from message babylon.checkpointing.v1.EventCheckpointSubmitted
 */
export class EventCheckpointSubmitted extends Message<EventCheckpointSubmitted> {
  /**
   * @generated from field: babylon.checkpointing.v1.RawCheckpointWithMeta checkpoint = 1;
   */
  checkpoint?: RawCheckpointWithMeta;

  constructor(data?: PartialMessage<EventCheckpointSubmitted>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.checkpointing.v1.EventCheckpointSubmitted";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "checkpoint", kind: "message", T: RawCheckpointWithMeta },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventCheckpointSubmitted {
    return new EventCheckpointSubmitted().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventCheckpointSubmitted {
    return new EventCheckpointSubmitted().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventCheckpointSubmitted {
    return new EventCheckpointSubmitted().fromJsonString(jsonString, options);
  }

  static equals(a: EventCheckpointSubmitted | PlainMessage<EventCheckpointSubmitted> | undefined, b: EventCheckpointSubmitted | PlainMessage<EventCheckpointSubmitted> | undefined): boolean {
    return proto3.util.equals(EventCheckpointSubmitted, a, b);
  }
}

/**
 * EventCheckpointConfirmed is emitted when a checkpoint reaches the `Confirmed`
 * state.
 *
 * @generated from message babylon.checkpointing.v1.EventCheckpointConfirmed
 */
export class EventCheckpointConfirmed extends Message<EventCheckpointConfirmed> {
  /**
   * @generated from field: babylon.checkpointing.v1.RawCheckpointWithMeta checkpoint = 1;
   */
  checkpoint?: RawCheckpointWithMeta;

  constructor(data?: PartialMessage<EventCheckpointConfirmed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.checkpointing.v1.EventCheckpointConfirmed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "checkpoint", kind: "message", T: RawCheckpointWithMeta },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventCheckpointConfirmed {
    return new EventCheckpointConfirmed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventCheckpointConfirmed {
    return new EventCheckpointConfirmed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventCheckpointConfirmed {
    return new EventCheckpointConfirmed().fromJsonString(jsonString, options);
  }

  static equals(a: EventCheckpointConfirmed | PlainMessage<EventCheckpointConfirmed> | undefined, b: EventCheckpointConfirmed | PlainMessage<EventCheckpointConfirmed> | undefined): boolean {
    return proto3.util.equals(EventCheckpointConfirmed, a, b);
  }
}

/**
 * EventCheckpointFinalized is emitted when a checkpoint reaches the `Finalized`
 * state.
 *
 * @generated from message babylon.checkpointing.v1.EventCheckpointFinalized
 */
export class EventCheckpointFinalized extends Message<EventCheckpointFinalized> {
  /**
   * @generated from field: babylon.checkpointing.v1.RawCheckpointWithMeta checkpoint = 1;
   */
  checkpoint?: RawCheckpointWithMeta;

  constructor(data?: PartialMessage<EventCheckpointFinalized>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.checkpointing.v1.EventCheckpointFinalized";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "checkpoint", kind: "message", T: RawCheckpointWithMeta },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventCheckpointFinalized {
    return new EventCheckpointFinalized().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventCheckpointFinalized {
    return new EventCheckpointFinalized().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventCheckpointFinalized {
    return new EventCheckpointFinalized().fromJsonString(jsonString, options);
  }

  static equals(a: EventCheckpointFinalized | PlainMessage<EventCheckpointFinalized> | undefined, b: EventCheckpointFinalized | PlainMessage<EventCheckpointFinalized> | undefined): boolean {
    return proto3.util.equals(EventCheckpointFinalized, a, b);
  }
}

/**
 * EventCheckpointForgotten is emitted when a checkpoint switches to a
 * `Forgotten` state.
 *
 * @generated from message babylon.checkpointing.v1.EventCheckpointForgotten
 */
export class EventCheckpointForgotten extends Message<EventCheckpointForgotten> {
  /**
   * @generated from field: babylon.checkpointing.v1.RawCheckpointWithMeta checkpoint = 1;
   */
  checkpoint?: RawCheckpointWithMeta;

  constructor(data?: PartialMessage<EventCheckpointForgotten>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.checkpointing.v1.EventCheckpointForgotten";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "checkpoint", kind: "message", T: RawCheckpointWithMeta },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventCheckpointForgotten {
    return new EventCheckpointForgotten().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventCheckpointForgotten {
    return new EventCheckpointForgotten().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventCheckpointForgotten {
    return new EventCheckpointForgotten().fromJsonString(jsonString, options);
  }

  static equals(a: EventCheckpointForgotten | PlainMessage<EventCheckpointForgotten> | undefined, b: EventCheckpointForgotten | PlainMessage<EventCheckpointForgotten> | undefined): boolean {
    return proto3.util.equals(EventCheckpointForgotten, a, b);
  }
}

/**
 * EventConflictingCheckpoint is emitted when two conflicting checkpoints are
 * found.
 *
 * @generated from message babylon.checkpointing.v1.EventConflictingCheckpoint
 */
export class EventConflictingCheckpoint extends Message<EventConflictingCheckpoint> {
  /**
   * @generated from field: babylon.checkpointing.v1.RawCheckpoint conflicting_checkpoint = 1;
   */
  conflictingCheckpoint?: RawCheckpoint;

  /**
   * @generated from field: babylon.checkpointing.v1.RawCheckpointWithMeta local_checkpoint = 2;
   */
  localCheckpoint?: RawCheckpointWithMeta;

  constructor(data?: PartialMessage<EventConflictingCheckpoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.checkpointing.v1.EventConflictingCheckpoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "conflicting_checkpoint", kind: "message", T: RawCheckpoint },
    { no: 2, name: "local_checkpoint", kind: "message", T: RawCheckpointWithMeta },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventConflictingCheckpoint {
    return new EventConflictingCheckpoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventConflictingCheckpoint {
    return new EventConflictingCheckpoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventConflictingCheckpoint {
    return new EventConflictingCheckpoint().fromJsonString(jsonString, options);
  }

  static equals(a: EventConflictingCheckpoint | PlainMessage<EventConflictingCheckpoint> | undefined, b: EventConflictingCheckpoint | PlainMessage<EventConflictingCheckpoint> | undefined): boolean {
    return proto3.util.equals(EventConflictingCheckpoint, a, b);
  }
}

