// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file babylon/zoneconcierge/v1/zoneconcierge.proto (package babylon.zoneconcierge.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { Epoch } from "../../epoching/v1/epoching_pb.js";
import { RawCheckpoint } from "../../checkpointing/v1/checkpoint_pb.js";
import { SubmissionKey, TransactionInfo } from "../../btccheckpoint/v1/btccheckpoint_pb.js";
import { ValidatorWithBlsKey } from "../../checkpointing/v1/bls_key_pb.js";
import { ProofOps } from "../../../tendermint/crypto/proof_pb.js";
import { BTCHeaderInfo } from "../../btclightclient/v1/btclightclient_pb.js";

/**
 * IndexedHeader is the metadata of a CZ header
 *
 * @generated from message babylon.zoneconcierge.v1.IndexedHeader
 */
export class IndexedHeader extends Message<IndexedHeader> {
  /**
   * chain_id is the unique ID of the chain
   *
   * @generated from field: string chain_id = 1;
   */
  chainId = "";

  /**
   * hash is the hash of this header
   *
   * @generated from field: bytes hash = 2;
   */
  hash = new Uint8Array(0);

  /**
   * height is the height of this header on CZ ledger
   * (hash, height) jointly provides the position of the header on CZ ledger
   *
   * @generated from field: uint64 height = 3;
   */
  height = protoInt64.zero;

  /**
   * time is the timestamp of this header on CZ ledger
   * it is needed for CZ to unbond all mature validators/delegations
   * before this timestamp when this header is BTC-finalised
   *
   * @generated from field: google.protobuf.Timestamp time = 4;
   */
  time?: Timestamp;

  /**
   * babylon_header_hash is the hash of the babylon block that includes this CZ
   * header
   *
   * @generated from field: bytes babylon_header_hash = 5;
   */
  babylonHeaderHash = new Uint8Array(0);

  /**
   * babylon_header_height is the height of the babylon block that includes this CZ
   * header
   *
   * @generated from field: uint64 babylon_header_height = 6;
   */
  babylonHeaderHeight = protoInt64.zero;

  /**
   * epoch is the epoch number of this header on Babylon ledger
   *
   * @generated from field: uint64 babylon_epoch = 7;
   */
  babylonEpoch = protoInt64.zero;

  /**
   * babylon_tx_hash is the hash of the tx that includes this header
   * (babylon_block_height, babylon_tx_hash) jointly provides the position of
   * the header on Babylon ledger
   *
   * @generated from field: bytes babylon_tx_hash = 8;
   */
  babylonTxHash = new Uint8Array(0);

  constructor(data?: PartialMessage<IndexedHeader>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.zoneconcierge.v1.IndexedHeader";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chain_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "time", kind: "message", T: Timestamp },
    { no: 5, name: "babylon_header_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "babylon_header_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "babylon_epoch", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 8, name: "babylon_tx_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IndexedHeader {
    return new IndexedHeader().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IndexedHeader {
    return new IndexedHeader().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IndexedHeader {
    return new IndexedHeader().fromJsonString(jsonString, options);
  }

  static equals(a: IndexedHeader | PlainMessage<IndexedHeader> | undefined, b: IndexedHeader | PlainMessage<IndexedHeader> | undefined): boolean {
    return proto3.util.equals(IndexedHeader, a, b);
  }
}

/**
 * Forks is a list of non-canonical `IndexedHeader`s at the same height.
 * For example, assuming the following blockchain
 * ```
 * A <- B <- C <- D <- E
 *            \ -- D1
 *            \ -- D2
 * ```
 * Then the fork will be {[D1, D2]} where each item is in struct `IndexedBlock`.
 *
 * Note that each `IndexedHeader` in the fork should have a valid quorum
 * certificate. Such forks exist since Babylon considers CZs might have
 * dishonest majority. Also note that the IBC-Go implementation will only
 * consider the first header in a fork valid, since the subsequent headers
 * cannot be verified without knowing the validator set in the previous header.
 *
 * @generated from message babylon.zoneconcierge.v1.Forks
 */
export class Forks extends Message<Forks> {
  /**
   * blocks is the list of non-canonical indexed headers at the same height
   *
   * @generated from field: repeated babylon.zoneconcierge.v1.IndexedHeader headers = 3;
   */
  headers: IndexedHeader[] = [];

  constructor(data?: PartialMessage<Forks>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.zoneconcierge.v1.Forks";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "headers", kind: "message", T: IndexedHeader, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Forks {
    return new Forks().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Forks {
    return new Forks().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Forks {
    return new Forks().fromJsonString(jsonString, options);
  }

  static equals(a: Forks | PlainMessage<Forks> | undefined, b: Forks | PlainMessage<Forks> | undefined): boolean {
    return proto3.util.equals(Forks, a, b);
  }
}

/**
 * ChainInfo is the information of a CZ
 *
 * @generated from message babylon.zoneconcierge.v1.ChainInfo
 */
export class ChainInfo extends Message<ChainInfo> {
  /**
   * chain_id is the ID of the chain
   *
   * @generated from field: string chain_id = 1;
   */
  chainId = "";

  /**
   * latest_header is the latest header in CZ's canonical chain
   *
   * @generated from field: babylon.zoneconcierge.v1.IndexedHeader latest_header = 2;
   */
  latestHeader?: IndexedHeader;

  /**
   * latest_forks is the latest forks, formed as a series of IndexedHeader (from
   * low to high)
   *
   * @generated from field: babylon.zoneconcierge.v1.Forks latest_forks = 3;
   */
  latestForks?: Forks;

  /**
   * timestamped_headers_count is the number of timestamped headers in CZ's
   * canonical chain
   *
   * @generated from field: uint64 timestamped_headers_count = 4;
   */
  timestampedHeadersCount = protoInt64.zero;

  constructor(data?: PartialMessage<ChainInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.zoneconcierge.v1.ChainInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chain_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "latest_header", kind: "message", T: IndexedHeader },
    { no: 3, name: "latest_forks", kind: "message", T: Forks },
    { no: 4, name: "timestamped_headers_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChainInfo {
    return new ChainInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChainInfo {
    return new ChainInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChainInfo {
    return new ChainInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ChainInfo | PlainMessage<ChainInfo> | undefined, b: ChainInfo | PlainMessage<ChainInfo> | undefined): boolean {
    return proto3.util.equals(ChainInfo, a, b);
  }
}

/**
 * FinalizedChainInfo is the information of a CZ that is BTC-finalised
 *
 * @generated from message babylon.zoneconcierge.v1.FinalizedChainInfo
 */
export class FinalizedChainInfo extends Message<FinalizedChainInfo> {
  /**
   * chain_id is the ID of the chain
   *
   * @generated from field: string chain_id = 1;
   */
  chainId = "";

  /**
   * finalized_chain_info is the info of the CZ
   *
   * @generated from field: babylon.zoneconcierge.v1.ChainInfo finalized_chain_info = 2;
   */
  finalizedChainInfo?: ChainInfo;

  /**
   * epoch_info is the metadata of the last BTC-finalised epoch
   *
   * @generated from field: babylon.epoching.v1.Epoch epoch_info = 3;
   */
  epochInfo?: Epoch;

  /**
   * raw_checkpoint is the raw checkpoint of this epoch
   *
   * @generated from field: babylon.checkpointing.v1.RawCheckpoint raw_checkpoint = 4;
   */
  rawCheckpoint?: RawCheckpoint;

  /**
   * btc_submission_key is position of two BTC txs that include the raw
   * checkpoint of this epoch
   *
   * @generated from field: babylon.btccheckpoint.v1.SubmissionKey btc_submission_key = 5;
   */
  btcSubmissionKey?: SubmissionKey;

  /**
   * proof is the proof that the chain info is finalized
   *
   * @generated from field: babylon.zoneconcierge.v1.ProofFinalizedChainInfo proof = 6;
   */
  proof?: ProofFinalizedChainInfo;

  constructor(data?: PartialMessage<FinalizedChainInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.zoneconcierge.v1.FinalizedChainInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chain_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "finalized_chain_info", kind: "message", T: ChainInfo },
    { no: 3, name: "epoch_info", kind: "message", T: Epoch },
    { no: 4, name: "raw_checkpoint", kind: "message", T: RawCheckpoint },
    { no: 5, name: "btc_submission_key", kind: "message", T: SubmissionKey },
    { no: 6, name: "proof", kind: "message", T: ProofFinalizedChainInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FinalizedChainInfo {
    return new FinalizedChainInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FinalizedChainInfo {
    return new FinalizedChainInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FinalizedChainInfo {
    return new FinalizedChainInfo().fromJsonString(jsonString, options);
  }

  static equals(a: FinalizedChainInfo | PlainMessage<FinalizedChainInfo> | undefined, b: FinalizedChainInfo | PlainMessage<FinalizedChainInfo> | undefined): boolean {
    return proto3.util.equals(FinalizedChainInfo, a, b);
  }
}

/**
 * ProofEpochSealed is the proof that an epoch is sealed by the sealer header,
 * i.e., the 2nd header of the next epoch With the access of metadata
 * - Metadata of this epoch, which includes the sealer header
 * - Raw checkpoint of this epoch
 * The verifier can perform the following verification rules:
 * - The raw checkpoint's `app_hash` is same as in the sealer header
 * - More than 2/3 (in voting power) validators in the validator set of this
 * epoch have signed `app_hash` of the sealer header
 * - The epoch metadata is committed to the `app_hash` of the sealer header
 * - The validator set is committed to the `app_hash` of the sealer header
 *
 * @generated from message babylon.zoneconcierge.v1.ProofEpochSealed
 */
export class ProofEpochSealed extends Message<ProofEpochSealed> {
  /**
   * validator_set is the validator set of the sealed epoch
   * This validator set has generated a BLS multisig on `app_hash` of
   * the sealer header
   *
   * @generated from field: repeated babylon.checkpointing.v1.ValidatorWithBlsKey validator_set = 1;
   */
  validatorSet: ValidatorWithBlsKey[] = [];

  /**
   * proof_epoch_info is the Merkle proof that the epoch's metadata is committed
   * to `app_hash` of the sealer header
   *
   * @generated from field: tendermint.crypto.ProofOps proof_epoch_info = 2;
   */
  proofEpochInfo?: ProofOps;

  /**
   * proof_epoch_info is the Merkle proof that the epoch's validator set is
   * committed to `app_hash` of the sealer header
   *
   * @generated from field: tendermint.crypto.ProofOps proof_epoch_val_set = 3;
   */
  proofEpochValSet?: ProofOps;

  constructor(data?: PartialMessage<ProofEpochSealed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.zoneconcierge.v1.ProofEpochSealed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validator_set", kind: "message", T: ValidatorWithBlsKey, repeated: true },
    { no: 2, name: "proof_epoch_info", kind: "message", T: ProofOps },
    { no: 3, name: "proof_epoch_val_set", kind: "message", T: ProofOps },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProofEpochSealed {
    return new ProofEpochSealed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProofEpochSealed {
    return new ProofEpochSealed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProofEpochSealed {
    return new ProofEpochSealed().fromJsonString(jsonString, options);
  }

  static equals(a: ProofEpochSealed | PlainMessage<ProofEpochSealed> | undefined, b: ProofEpochSealed | PlainMessage<ProofEpochSealed> | undefined): boolean {
    return proto3.util.equals(ProofEpochSealed, a, b);
  }
}

/**
 * ProofFinalizedChainInfo is a set of proofs that attest a chain info is
 * BTC-finalised
 *
 *
 * The following fields include proofs that attest the chain info is
 * BTC-finalised
 *
 * @generated from message babylon.zoneconcierge.v1.ProofFinalizedChainInfo
 */
export class ProofFinalizedChainInfo extends Message<ProofFinalizedChainInfo> {
  /**
   * proof_cz_header_in_epoch is the proof that the CZ header is timestamped
   * within a certain epoch
   *
   * @generated from field: tendermint.crypto.ProofOps proof_cz_header_in_epoch = 1;
   */
  proofCzHeaderInEpoch?: ProofOps;

  /**
   * proof_epoch_sealed is the proof that the epoch is sealed
   *
   * @generated from field: babylon.zoneconcierge.v1.ProofEpochSealed proof_epoch_sealed = 2;
   */
  proofEpochSealed?: ProofEpochSealed;

  /**
   * proof_epoch_submitted is the proof that the epoch's checkpoint is included
   * in BTC ledger It is the two TransactionInfo in the best (i.e., earliest)
   * checkpoint submission
   *
   * @generated from field: repeated babylon.btccheckpoint.v1.TransactionInfo proof_epoch_submitted = 3;
   */
  proofEpochSubmitted: TransactionInfo[] = [];

  constructor(data?: PartialMessage<ProofFinalizedChainInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.zoneconcierge.v1.ProofFinalizedChainInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proof_cz_header_in_epoch", kind: "message", T: ProofOps },
    { no: 2, name: "proof_epoch_sealed", kind: "message", T: ProofEpochSealed },
    { no: 3, name: "proof_epoch_submitted", kind: "message", T: TransactionInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProofFinalizedChainInfo {
    return new ProofFinalizedChainInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProofFinalizedChainInfo {
    return new ProofFinalizedChainInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProofFinalizedChainInfo {
    return new ProofFinalizedChainInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ProofFinalizedChainInfo | PlainMessage<ProofFinalizedChainInfo> | undefined, b: ProofFinalizedChainInfo | PlainMessage<ProofFinalizedChainInfo> | undefined): boolean {
    return proto3.util.equals(ProofFinalizedChainInfo, a, b);
  }
}

/**
 * Btc light client chain segment grown during last finalized epoch
 *
 * @generated from message babylon.zoneconcierge.v1.BTCChainSegment
 */
export class BTCChainSegment extends Message<BTCChainSegment> {
  /**
   * @generated from field: repeated babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 1;
   */
  btcHeaders: BTCHeaderInfo[] = [];

  constructor(data?: PartialMessage<BTCChainSegment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.zoneconcierge.v1.BTCChainSegment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "btc_headers", kind: "message", T: BTCHeaderInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BTCChainSegment {
    return new BTCChainSegment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BTCChainSegment {
    return new BTCChainSegment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BTCChainSegment {
    return new BTCChainSegment().fromJsonString(jsonString, options);
  }

  static equals(a: BTCChainSegment | PlainMessage<BTCChainSegment> | undefined, b: BTCChainSegment | PlainMessage<BTCChainSegment> | undefined): boolean {
    return proto3.util.equals(BTCChainSegment, a, b);
  }
}

