// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file babylon/btccheckpoint/v1/query.proto (package babylon.btccheckpoint.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Params } from "./params_pb.js";
import { PageRequest, PageResponse } from "../../../cosmos/base/query/v1beta1/pagination_pb.js";

/**
 * QueryParamsRequest is request type for the Query/Params RPC method.
 *
 * @generated from message babylon.btccheckpoint.v1.QueryParamsRequest
 */
export class QueryParamsRequest extends Message<QueryParamsRequest> {
  constructor(data?: PartialMessage<QueryParamsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btccheckpoint.v1.QueryParamsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryParamsRequest {
    return new QueryParamsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryParamsRequest {
    return new QueryParamsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryParamsRequest {
    return new QueryParamsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryParamsRequest | PlainMessage<QueryParamsRequest> | undefined, b: QueryParamsRequest | PlainMessage<QueryParamsRequest> | undefined): boolean {
    return proto3.util.equals(QueryParamsRequest, a, b);
  }
}

/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 *
 * @generated from message babylon.btccheckpoint.v1.QueryParamsResponse
 */
export class QueryParamsResponse extends Message<QueryParamsResponse> {
  /**
   * params holds all the parameters of this module.
   *
   * @generated from field: babylon.btccheckpoint.v1.Params params = 1;
   */
  params?: Params;

  constructor(data?: PartialMessage<QueryParamsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btccheckpoint.v1.QueryParamsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: Params },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryParamsResponse {
    return new QueryParamsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryParamsResponse {
    return new QueryParamsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryParamsResponse {
    return new QueryParamsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryParamsResponse | PlainMessage<QueryParamsResponse> | undefined, b: QueryParamsResponse | PlainMessage<QueryParamsResponse> | undefined): boolean {
    return proto3.util.equals(QueryParamsResponse, a, b);
  }
}

/**
 * QueryBtcCheckpointInfoRequest defines the query to get the best checkpoint
 * for a given epoch
 *
 * @generated from message babylon.btccheckpoint.v1.QueryBtcCheckpointInfoRequest
 */
export class QueryBtcCheckpointInfoRequest extends Message<QueryBtcCheckpointInfoRequest> {
  /**
   * Number of epoch for which the earliest checkpointing btc height is
   * requested
   *
   * @generated from field: uint64 epoch_num = 1;
   */
  epochNum = protoInt64.zero;

  constructor(data?: PartialMessage<QueryBtcCheckpointInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btccheckpoint.v1.QueryBtcCheckpointInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "epoch_num", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBtcCheckpointInfoRequest {
    return new QueryBtcCheckpointInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBtcCheckpointInfoRequest {
    return new QueryBtcCheckpointInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBtcCheckpointInfoRequest {
    return new QueryBtcCheckpointInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBtcCheckpointInfoRequest | PlainMessage<QueryBtcCheckpointInfoRequest> | undefined, b: QueryBtcCheckpointInfoRequest | PlainMessage<QueryBtcCheckpointInfoRequest> | undefined): boolean {
    return proto3.util.equals(QueryBtcCheckpointInfoRequest, a, b);
  }
}

/**
 * QueryBtcCheckpointInfoResponse is response type for the
 * Query/BtcCheckpointInfo RPC method
 *
 * @generated from message babylon.btccheckpoint.v1.QueryBtcCheckpointInfoResponse
 */
export class QueryBtcCheckpointInfoResponse extends Message<QueryBtcCheckpointInfoResponse> {
  /**
   * @generated from field: babylon.btccheckpoint.v1.BTCCheckpointInfoResponse info = 1;
   */
  info?: BTCCheckpointInfoResponse;

  constructor(data?: PartialMessage<QueryBtcCheckpointInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btccheckpoint.v1.QueryBtcCheckpointInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "info", kind: "message", T: BTCCheckpointInfoResponse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBtcCheckpointInfoResponse {
    return new QueryBtcCheckpointInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBtcCheckpointInfoResponse {
    return new QueryBtcCheckpointInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBtcCheckpointInfoResponse {
    return new QueryBtcCheckpointInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBtcCheckpointInfoResponse | PlainMessage<QueryBtcCheckpointInfoResponse> | undefined, b: QueryBtcCheckpointInfoResponse | PlainMessage<QueryBtcCheckpointInfoResponse> | undefined): boolean {
    return proto3.util.equals(QueryBtcCheckpointInfoResponse, a, b);
  }
}

/**
 * QueryBtcCheckpointsInfoRequest is request type for the
 * Query/BtcCheckpointsInfo RPC method
 *
 * @generated from message babylon.btccheckpoint.v1.QueryBtcCheckpointsInfoRequest
 */
export class QueryBtcCheckpointsInfoRequest extends Message<QueryBtcCheckpointsInfoRequest> {
  /**
   * pagination defines whether to have the pagination in the request
   *
   * @generated from field: cosmos.base.query.v1beta1.PageRequest pagination = 1;
   */
  pagination?: PageRequest;

  constructor(data?: PartialMessage<QueryBtcCheckpointsInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btccheckpoint.v1.QueryBtcCheckpointsInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pagination", kind: "message", T: PageRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBtcCheckpointsInfoRequest {
    return new QueryBtcCheckpointsInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBtcCheckpointsInfoRequest {
    return new QueryBtcCheckpointsInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBtcCheckpointsInfoRequest {
    return new QueryBtcCheckpointsInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBtcCheckpointsInfoRequest | PlainMessage<QueryBtcCheckpointsInfoRequest> | undefined, b: QueryBtcCheckpointsInfoRequest | PlainMessage<QueryBtcCheckpointsInfoRequest> | undefined): boolean {
    return proto3.util.equals(QueryBtcCheckpointsInfoRequest, a, b);
  }
}

/**
 * QueryBtcCheckpointsInfoResponse is response type for the
 * Query/BtcCheckpointsInfo RPC method
 *
 * @generated from message babylon.btccheckpoint.v1.QueryBtcCheckpointsInfoResponse
 */
export class QueryBtcCheckpointsInfoResponse extends Message<QueryBtcCheckpointsInfoResponse> {
  /**
   * @generated from field: repeated babylon.btccheckpoint.v1.BTCCheckpointInfoResponse info_list = 1;
   */
  infoList: BTCCheckpointInfoResponse[] = [];

  /**
   * pagination defines the pagination in the response
   *
   * @generated from field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
   */
  pagination?: PageResponse;

  constructor(data?: PartialMessage<QueryBtcCheckpointsInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btccheckpoint.v1.QueryBtcCheckpointsInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "info_list", kind: "message", T: BTCCheckpointInfoResponse, repeated: true },
    { no: 2, name: "pagination", kind: "message", T: PageResponse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBtcCheckpointsInfoResponse {
    return new QueryBtcCheckpointsInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBtcCheckpointsInfoResponse {
    return new QueryBtcCheckpointsInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBtcCheckpointsInfoResponse {
    return new QueryBtcCheckpointsInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBtcCheckpointsInfoResponse | PlainMessage<QueryBtcCheckpointsInfoResponse> | undefined, b: QueryBtcCheckpointsInfoResponse | PlainMessage<QueryBtcCheckpointsInfoResponse> | undefined): boolean {
    return proto3.util.equals(QueryBtcCheckpointsInfoResponse, a, b);
  }
}

/**
 * QueryEpochSubmissionsRequest defines a request to get all submissions in
 * given epoch
 *
 * @generated from message babylon.btccheckpoint.v1.QueryEpochSubmissionsRequest
 */
export class QueryEpochSubmissionsRequest extends Message<QueryEpochSubmissionsRequest> {
  /**
   * Number of epoch for which submissions are requested
   *
   * @generated from field: uint64 epoch_num = 1;
   */
  epochNum = protoInt64.zero;

  constructor(data?: PartialMessage<QueryEpochSubmissionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btccheckpoint.v1.QueryEpochSubmissionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "epoch_num", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryEpochSubmissionsRequest {
    return new QueryEpochSubmissionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryEpochSubmissionsRequest {
    return new QueryEpochSubmissionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryEpochSubmissionsRequest {
    return new QueryEpochSubmissionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryEpochSubmissionsRequest | PlainMessage<QueryEpochSubmissionsRequest> | undefined, b: QueryEpochSubmissionsRequest | PlainMessage<QueryEpochSubmissionsRequest> | undefined): boolean {
    return proto3.util.equals(QueryEpochSubmissionsRequest, a, b);
  }
}

/**
 * QueryEpochSubmissionsResponse defines a response to get all submissions in
 * given epoch (QueryEpochSubmissionsRequest)
 *
 * @generated from message babylon.btccheckpoint.v1.QueryEpochSubmissionsResponse
 */
export class QueryEpochSubmissionsResponse extends Message<QueryEpochSubmissionsResponse> {
  /**
   * Keys All submissions transactions key saved during an epoch.
   *
   * @generated from field: repeated babylon.btccheckpoint.v1.SubmissionKeyResponse keys = 1;
   */
  keys: SubmissionKeyResponse[] = [];

  constructor(data?: PartialMessage<QueryEpochSubmissionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btccheckpoint.v1.QueryEpochSubmissionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "keys", kind: "message", T: SubmissionKeyResponse, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryEpochSubmissionsResponse {
    return new QueryEpochSubmissionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryEpochSubmissionsResponse {
    return new QueryEpochSubmissionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryEpochSubmissionsResponse {
    return new QueryEpochSubmissionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryEpochSubmissionsResponse | PlainMessage<QueryEpochSubmissionsResponse> | undefined, b: QueryEpochSubmissionsResponse | PlainMessage<QueryEpochSubmissionsResponse> | undefined): boolean {
    return proto3.util.equals(QueryEpochSubmissionsResponse, a, b);
  }
}

/**
 * BTCCheckpointInfoResponse contains all data about best submission of checkpoint for
 * given epoch. Best submission is the submission which is deeper in btc ledger.
 *
 * @generated from message babylon.btccheckpoint.v1.BTCCheckpointInfoResponse
 */
export class BTCCheckpointInfoResponse extends Message<BTCCheckpointInfoResponse> {
  /**
   * EpochNumber of this checkpoint.
   *
   * @generated from field: uint64 epoch_number = 1;
   */
  epochNumber = protoInt64.zero;

  /**
   * btc height of the best submission of the epoch
   *
   * @generated from field: uint64 best_submission_btc_block_height = 2;
   */
  bestSubmissionBtcBlockHeight = protoInt64.zero;

  /**
   * hash of the btc block which determines checkpoint btc block height i.e.
   * youngest block of best submission Hexadecimal
   *
   * @generated from field: string best_submission_btc_block_hash = 3;
   */
  bestSubmissionBtcBlockHash = "";

  /**
   * the BTC checkpoint transactions of the best submission
   *
   * @generated from field: repeated babylon.btccheckpoint.v1.TransactionInfoResponse best_submission_transactions = 4;
   */
  bestSubmissionTransactions: TransactionInfoResponse[] = [];

  /**
   * list of vigilantes' addresses of the best submission
   *
   * @generated from field: repeated babylon.btccheckpoint.v1.CheckpointAddressesResponse best_submission_vigilante_address_list = 5;
   */
  bestSubmissionVigilanteAddressList: CheckpointAddressesResponse[] = [];

  constructor(data?: PartialMessage<BTCCheckpointInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btccheckpoint.v1.BTCCheckpointInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "epoch_number", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "best_submission_btc_block_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "best_submission_btc_block_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "best_submission_transactions", kind: "message", T: TransactionInfoResponse, repeated: true },
    { no: 5, name: "best_submission_vigilante_address_list", kind: "message", T: CheckpointAddressesResponse, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BTCCheckpointInfoResponse {
    return new BTCCheckpointInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BTCCheckpointInfoResponse {
    return new BTCCheckpointInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BTCCheckpointInfoResponse {
    return new BTCCheckpointInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BTCCheckpointInfoResponse | PlainMessage<BTCCheckpointInfoResponse> | undefined, b: BTCCheckpointInfoResponse | PlainMessage<BTCCheckpointInfoResponse> | undefined): boolean {
    return proto3.util.equals(BTCCheckpointInfoResponse, a, b);
  }
}

/**
 * TransactionInfoResponse is the info of a tx on Bitcoin,
 * including
 * - the position of the tx on BTC blockchain
 * - the full tx content
 * - the Merkle proof that this tx is on the above position
 *
 * @generated from message babylon.btccheckpoint.v1.TransactionInfoResponse
 */
export class TransactionInfoResponse extends Message<TransactionInfoResponse> {
  /**
   * Index Bitcoin Transaction index in block.
   *
   * @generated from field: uint32 index = 1;
   */
  index = 0;

  /**
   * Hash BTC Header hash as hex.
   *
   * @generated from field: string hash = 2;
   */
  hash = "";

  /**
   * transaction is the full transaction data as str hex.
   *
   * @generated from field: string transaction = 3;
   */
  transaction = "";

  /**
   * proof is the Merkle proof that this tx is included in the position in `key`
   *
   * @generated from field: string proof = 4;
   */
  proof = "";

  constructor(data?: PartialMessage<TransactionInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btccheckpoint.v1.TransactionInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "transaction", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "proof", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionInfoResponse {
    return new TransactionInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionInfoResponse {
    return new TransactionInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionInfoResponse {
    return new TransactionInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionInfoResponse | PlainMessage<TransactionInfoResponse> | undefined, b: TransactionInfoResponse | PlainMessage<TransactionInfoResponse> | undefined): boolean {
    return proto3.util.equals(TransactionInfoResponse, a, b);
  }
}

/**
 * CheckpointAddressesResponse contains the addresses of the submitter and reporter of a
 * given checkpoint
 *
 * @generated from message babylon.btccheckpoint.v1.CheckpointAddressesResponse
 */
export class CheckpointAddressesResponse extends Message<CheckpointAddressesResponse> {
  /**
   * submitter is the address of the checkpoint submitter to BTC, extracted from
   * the checkpoint itself.
   *
   * @generated from field: string submitter = 1;
   */
  submitter = "";

  /**
   * reporter is the address of the reporter who reported the submissions,
   * calculated from submission message MsgInsertBTCSpvProof itself
   *
   * @generated from field: string reporter = 2;
   */
  reporter = "";

  constructor(data?: PartialMessage<CheckpointAddressesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btccheckpoint.v1.CheckpointAddressesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "submitter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "reporter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckpointAddressesResponse {
    return new CheckpointAddressesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckpointAddressesResponse {
    return new CheckpointAddressesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckpointAddressesResponse {
    return new CheckpointAddressesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CheckpointAddressesResponse | PlainMessage<CheckpointAddressesResponse> | undefined, b: CheckpointAddressesResponse | PlainMessage<CheckpointAddressesResponse> | undefined): boolean {
    return proto3.util.equals(CheckpointAddressesResponse, a, b);
  }
}

/**
 * SubmissionKeyResponse Checkpoint can be composed from multiple transactions,
 * so to identify whole submission we need list of transaction keys.
 * Each submission can generally be identified by this list of (txIdx,
 * blockHash) tuples. Note: this could possibly be optimized as if transactions
 * were in one block they would have the same block hash and different indexes,
 * but each blockhash is only 33 (1  byte for prefix encoding and 32 byte hash),
 * so there should be other strong arguments for this optimization
 *
 * @generated from message babylon.btccheckpoint.v1.SubmissionKeyResponse
 */
export class SubmissionKeyResponse extends Message<SubmissionKeyResponse> {
  /**
   * FirstTxBlockHash is the BTCHeaderHashBytes in hex.
   *
   * @generated from field: string first_tx_block_hash = 1;
   */
  firstTxBlockHash = "";

  /**
   * @generated from field: uint32 first_tx_index = 2;
   */
  firstTxIndex = 0;

  /**
   * SecondBlockHash is the BTCHeaderHashBytes in hex.
   *
   * @generated from field: string second_tx_block_hash = 3;
   */
  secondTxBlockHash = "";

  /**
   * @generated from field: uint32 second_tx_index = 4;
   */
  secondTxIndex = 0;

  constructor(data?: PartialMessage<SubmissionKeyResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "babylon.btccheckpoint.v1.SubmissionKeyResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "first_tx_block_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "first_tx_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "second_tx_block_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "second_tx_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmissionKeyResponse {
    return new SubmissionKeyResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmissionKeyResponse {
    return new SubmissionKeyResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmissionKeyResponse {
    return new SubmissionKeyResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SubmissionKeyResponse | PlainMessage<SubmissionKeyResponse> | undefined, b: SubmissionKeyResponse | PlainMessage<SubmissionKeyResponse> | undefined): boolean {
    return proto3.util.equals(SubmissionKeyResponse, a, b);
  }
}

